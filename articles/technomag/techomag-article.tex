\documentclass[12pt,a4paper,fleqn]{article}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{misccorr}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}

\usepackage[left=20mm,right=20mm,top=20mm,bottom=20mm]{geometry}

\sloppy
\hyphenpenalty=9000

\makeatletter
\renewcommand\@biblabel[1]{\hfill#1.}
\makeatother

\pagestyle{empty}

\begin{document}

\begin{center}
\huge Параллельная проверка утверждений для моделей конечных детерминированных систем
\end{center}

\vspace{5mm}

\begin{center}
И.А.~Коротков, В.А.~Крищенко\\
\it Московский государственный технический университет им.~Н.~Э.~Баумана\\\
\rm
Россия, 105005, Москва, 2-ая Бауманская, 5\\
E-mail: kva@bmstu.ru

\hspace{1.25cm}

\vspace{8mm}

\begin{minipage}{12.16cm}\noindent

\footnotesize{\bf Ключевые слова:} формальная верификация, проверка моделей, генерация состояний, параллельные
вычисления, Promela

\noindent{\bf Key words:} model checking, state generation, parallel statespace, parallelism, Promela

\vspace{6mm}

\noindent Основной проблемой верификации конечных моделей является комбинаторный <<взрыв>> числа состояний, которые с
ростом размера модели становится затруднительно хранить в ОЗУ одной машины. Рассматривается подход к верификации
конечных моделей на основе параллельной генерации состояний и их распределенного хранения. Предлагается схема
распределенного хранения состояний, позволяющая уменьшить число удаленных вызовов между узлами в процессе
генерации. Приводятся результаты экспериментов, полученные при помощи разработанного программного средства.

\vspace{4mm}

\noindent {\bf Parallel statespace generation during model-checking for systems with distributed memory} /
I.\,A.\,Korotkov (Moscow State Technical Univercity, 5 Baumanskay 2-aya ul., Moscow 105005, Russia,
e-mail:~korotkov2@mail.ru).

Major limitation of model checking is statespace combinatorial explosion, which makes even medium-sized model
inappropriate for that kind of verification. In this paper, parallel statespace generation with distributed state
storage is proposed as a possible solution. State partitioning scheme that allows to reduce number of remote calls
during generation process is developed.  Experimental results, produced by developed verification tool, are given and
prove that proposed partitioning scheme is better than random uniform distribution.
\end{minipage}

\end{center}


\section{Проверка конечных моделей}
\label{sec:modelchecking}

Пространство состояний детерминированной системы, например, моделируемой программы, можно формализовать в виде модели Крипке~\cite{Clarke}.
Моделью Крипке $M$ над множеством атомарных высказываний $AP$
называют четверку $(S, S_0, R, L)$, где:

\begin{itemize}
\item $S$~--- конечное множество состояний;
\item $S_0 \in S$~--- множество начальных состояний;
\item $R \in S \times S$~--- отношение переходов, которые обязано быть тотальным, т.е. для каждого состояния $s \in S$
  должно существовать такое состояние $s' \in S$, что имеет место $R(s, s')$;
\item $L\colon S \rightarrow 2^{AP}$~--- функция, которая помечает каждое состояние множеством  атомарных высказываний, истинных в этом состоянии.
\end{itemize}

Путь в модели $M$ из состояния $s$~--- это бесконечная последовательность состояний $\pi = s_0 s_1 \ldots$, такая, что
$s_o = s$ и для всех $i \geq 0$ выполняется $R(s_i, s_{i+1})$.

Моделируемая программа в каждом своем состоянии описывается набором значений переменных $V = \{v_0, v_1, \ldots\}$, принимающих значения на конечном множестве $D$ (домене интерпретации) и описывающих отдельные компоненты модели и взаимодействие между ними.
Множество $AP$ состоит из утверждений вида $v_i = d_i$, где $d_i \in D$.
Таким образом, каждое состояние $s$ в $M$ представляет собой отображение $V \rightarrow D$.

Отношение $R$ определяется следующим образом. Пусть имеются два состояния, $s_1$ и $s_2$. Если в $s_1$ имеется
компонент, который может выполнить атомарный переход (изменение значений своих переменных), в результате выполнения
которого система будет находиться в состоянии $s_2$, тогда состояния $s_1$ и $s_2$ связаны отношением перехода: $(s_1,
s_2) \in R$. В случае, если нет такого состояния $s_2$, для которого бы выполнялось $R(s_1, s_2)$, полагается $R(s_1,
s_1)$, т.е. <<тупиковое>> состояние связано отношение перехода само с собой.

Для формализации проверяемых на модели $M$ утверждений обычно используются временные логики~\cite{Clarke, Velder}.
Однако, для проверки моделей программных систем наиболее актуальны два вида высказываний:
\begin{itemize}
\item утверждение о постоянном выполнении некоего условия в заданной точке компонента, что является аналогом конструкции \textbf{assert} при программировании;
\item утверждение о завершении работы модели или её функционировании в вечном цикле, что важно при поиске тупиков в программной системе.
\end{itemize}


\section{Язык Promela}
\label{sec:spin}

Наиболее распространенным средством проверки конечных моделей является ПО SPIN, использующее для описания исходной
модели язык Promela~\cite{SPIN}.

Модель на языке Promela описывается в виде набора процессов (компонент модели), состоящих из последовательности команд.
Каждый процесс имеет свой набор локальных переменных, в том числе счетчик команд.
Для взаимодействия между процессами могут использоваться глобальные переменные и очереди сообщений.
Каждая команда имеет свое условие выполнимости, и процесс считается заблокированным, если условие выполнимости его текущей команды не выполнено.

Пример описания модели семафора Дейкстры и трех захватывающих его процессов в нотации языка Promela приведен ниже.
Для данной модели представляет интерес утверждение о «вечном» выполнении модели, что будет свидетельствовать об отсутствии тупиков.

\begin{verbatim}
mtype { p, v };
chan sema = [0] of { mtype };
active proctype dijkstra()
{      byte count = 1;
       do
       :: (count == 1) ->
               sema!p; count--
       :: (count == 0) ->
               sema?v; count++
       od
}
active [3] proctype concurent_user()
{       do
        :: enter: sema?p;  /* вход в критическую секцию */
            crit: skip;    /* критическая секция */
           leave: sema!v;  /* выход из критической секции */
        od
}
\end{verbatim}

\section{Параллельная генерация состояний}
\label{sec:pargen}

При росте числа и сложности компонент моделируемого программной системы в случае наблюдается комбинаторный рост числа
возможных состояний.
Поскольку граф состояний в общем случае имеет циклы, необходимо хранить множество посещенных состояний, которое быстро перестаёт помещаться в ОЗУ одной машины, а использование внешней памяти приведет к увеличению времени проверки на 3--4 порядка.

В настоящий момент на практике применяется ряд оптимизаций, позволяющих сократить как число состояний, так и требуемый для их хранения объем ОЗУ: сокращение частных порядков~\cite{POD}, битовое хэширование без обнаружения коллизий~\cite{BitHash1, Wolper}, сжатие состояний~\cite{StateCompr}).
Однако, данные меры либо дают небольшой, плохо масштабируемый прирост, либо приводят к потенциальным потерям
состояний при обходе.
Альтернативным подходом является параллельная генерация состояний с распределенным
хранением по различным узлам вычислительного кластера.

Возможны два подхода к параллельной генерации состояний.

\begin{enumerate}
\item Распределенное хранилище состояний. Состояния генерирует только один узел, а для хранения используются все
  узлы. Каждое состояние имеет свой однозначно вычислимый номер узла и для проверки, принадлежит ли следующее состояние
  множеству посещенных, делается синхронный удаленный вызов хранящего это состояние узла.

\item Распределенная генерация состояний. Каждый узел является одновременно хранилищем и генератором. Если новое
  состояние принадлежит другому узлу, оно высылается ему асинхронным удаленным вызовом. На
  рис.~\ref{fig:distr-generation} показан пример обхода графа при данном подходе. Цифры рядом с состояниями обозначают
  локальный порядок генерации (в пределах данного узла).
\end{enumerate}

Несмотря на очевидные преимущества (использование вычислительной мощности всех узлов, асинхронные вызовы вместо
синхронных), второй подход имеет свой недостаток: отсутствие какого-либо глобального порядка обхода состояний. Проверка
определенных классов утверждений (например, LTL-формул) требует поиска циклов в графе состояний, то есть обхода в
глубину. В данной статье рассматривается лишь генерация состояний; вопрос нахождения таких циклов при распределенной
генерации выходит за ее рамки и подробно рассмотрен в~\cite{DLTL1,DLTL2}.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.6\textwidth]{graphics/distr-generation-2}
  \caption{Пример работы распределенной генерации состояний}
  \label{fig:distr-generation}
\end{figure}

Одной из основных проблем распределенной генерации состояний является выбор функции распределения состояний между
узлами.

\section{Распределение состояний между узлами}
\label{sec:state-partition}

Функция распределения ставит в соответствие каждому состоянию индекс узла, отвечающего за хранение данного
состояний. Эта функция должна обладать следующими свойствами:

\begin{itemize}
\item она должна зависеть только от битового представления самого состояния, поскольку одно и то же состояние
  может генерироваться различными узлами в результате различных переходов;

\item она должна распределять состояния между узлами достаточно равномерно, в противном случае часть памяти у некоторых
  узлов будет простаивать;

\item она должна обладать свойством локальности относительно переходов между состояниями~--- по возможности новые
  состояния должны принадлежать тому же узлу, что и исходное.
\end{itemize}

Последнее условие имеет смысл лишь при втором подходе, <<распределенной генерации состояний>>, и позволяет уменьшить число
асинхронных удаленных вызовов между узлами.

Наиболее простым подходом является использование хэш-функции от битового представление состояния $s$ в качестве индекса
хранящего его узла. Это обеспечит первые два условия: если выбрана подходящая хэш-функция, распределение будет
достаточно равномерным. Однако, третье условие при этом не соблюдается, поскольку все новые состояния имеют равные шансы
принадлежать любому узлу независимо того, на каком узле они были сгенерированы.

Пусть число узлов~--- $N$, состояний~--- $S$, переходов между ними~--- $T$. В случае равномерного распределения
состояний между узлами вероятность того, что следующее состояние будет принадлежать текущему узлу, равняется
$1/N$. Следовательно, вероятность того, что потребуется удаленный вызов, равна $1 - 1/N$, а среднее число удаленных
вызовов в течение всей генерации составит
\begin{equation}
  \label{eq:rpc-partfull}
  Q = T (1 - \frac{1}{N}),
\end{equation}
что при больших значениях стремится к $T$.

Cтоль высокое число удаленных вызовов негативно отражаются на производительности, поэтому необходимо найти более удачную
функцию распределения состояний, которая бы удовлетворяла условию локальности. Одна из возможных идей предложена
в~\cite{LS99}: использовать хэш-код не от всего состояния $s$, а от некоторой его части $\tilde{s}$.

Битовое представление состояния в общем случае представляет собой набор значений переменных, описывающих состояние
отдельных компонент моделируемой системы и значения общих переменных, описывающих взаимодействие между ними.

Пусть $P$~--- число таких компонент (процессов в нотации Promela) в модели, $k$~--- среднее число компонент, состояние
которых меняется при переходе. Для языка Promela $1 \approx k < 2$ , поскольку взаимодействие между более чем двумя
процессами\footnote{Далее под словом <<процесс>> будет подразумеваться процесс в понимании Promela, т.е. компонент
  моделируемой системы.} нереализуемо, но для двух процессов есть возможность синхронной передачи сообщения, при которой
оба меняют свое состояние. Последняя возможность используется нечасто, поэтому для большинства моделей $k$ достаточно
близко к 1.

Таким образом, битовое представления состояния естественным образом разделяется на $(P+1)$ область, с учетом области
глобальных переменных. При этом $P$ из них меняются почти независимо друг от друга при условии $k \approx 1$, и в
качестве хэшируемого подсостояния $\tilde{s}$ можно выбрать первые (или произвольные) $\rho$ областей, хранящих
локальные состояния первых $\rho$ процессов.

Если предположить, что каждый процесс $p_i$ участвует примерно в равной доле переходов, то для произвольного наперед
заданного процесса вероятность участия в данном переходе составит $k/\rho$, а для $\rho$ процессов при $k \approx 1$
либо небольшом $\rho$~--- $\frac{k \rho}{P}$. При условии, что множество возможных локальных состояний процесса
отображается на множество узлов равномерным образом, вероятность удаленного вызова при изменении локального состояния
процесса (т.е. при его участии в переходе), по аналогии с предыдущими рассуждениями, составит $1 - 1/N$. Количество
удаленных вызовов во всей модели, таким образом, равняется
\begin{equation}
  \label{eq:rpc-partproc}
  Q_\rho = \frac{k \rho}{P} T (1 - \frac{1}{N})
\end{equation}

и с ростом $N$ стремится к $\frac{k \rho}{P} T$. При количестве процессов $P = 10$, $k = 1.1$ и $\rho = 2$, число
удаленных вызовов уменьшается примерно в 4 раза в сравнении с <<наивным>> подходом.

Выбор меньших значений $\rho$ приводит к меньшему числу удаленных вызовов, однако увеличивает неравномерность
распределения, поэтому его значение следует выбирать из баланса между требуемоей равномерностью распределения состояний
и выигрышем во времени за счет уменьшения числа вызовов.

Пусть $i$-ый процесс $p_i$ имеет $w_i$ возможных значений локального состояний, т.е. число допустимых комбинаций
значений его переменных составляет $w_i$. Объединение локальных состояний $\rho$ процессов тогда имеет не более $W_\rho
= \prod_{i=1}^{\rho}{w_i}$ возможных значений. Число значений может быть меньше $W_\rho$, поскольку в общем случае не
все комбинации являются допустимыми. Значение $\rho$ должно обеспечивать условие $W_\rho \gg N$, иначе, особенно при
$W_\rho \approx N$, распределение будет неравномерным даже при удачном выборе хэш-функции, а при $W_\rho < N$ память
некоторых узлов не будет использоваться вообще, так как число возможных значений хэш-функции будем меньше числа узлов.

\section{Реализация}
\label{sec:experim}

Было создано программное средство для параллельной проверки состояний с распределенной генерацией, поддерживающее основные возможности языка Promela для описания модели и проверку утверждений с функцией \textbf{assert} и поиском тупиковых состояний.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{graphics/stategen-idef0-simple}
  \caption{Функциональная схема процесса генерации кода по описанию модели}
  \label{fig:stategen-idef0-simple}
\end{figure}

Разработанное ПО работает следующим образом (рис.~\ref{fig:stategen-idef0-simple}). Исходная модель на Promela считывается и транслируется во внутренний граф команд для каждого процесса, который затем минимизируется.
С целью достижения скорости генерации состояний, сравнимой со скоростью системы SPIN, по полученным графам команд генерируется код на языке~C, выполняющий вычисление функции переходов модели $Next(s) = \{s': R(s, s')\}$ и функции проверки состояний $Assert(s): S \rightarrow \{0, 1\}$. В качестве платформы для параллельных вычислений в системе используется вычислительный кластер, поддерживающий стандарт MPI.

\section{Результаты экспериментов}

В качестве исходных данных для экспериментов были взяты две модели: выбора лидера и <<обедающие философы>> с числом компонент $P = 6$.
Для проведения экспериментов использовался MPI-кластер из 20 узлов, имеющих 4 Гб ОЗУ и 4 ЦПУ Intel\,Xeon\,5120~1.86 ГГц каждый.


Результаты экспериментов по сравнению предлагаемого распределения с $\rho = 1$ и $\rho = 2$ с наивным представлены на
табл.~\ref{tab:election-results} и~\ref{tab:philo-results}.

\begin{table}[htb]
  \centering
  \begin{tabular}{|c|c|c|c|c|}
    \hline
    $\rho$ & Доля внешних        & Неравномерность   & Время простоя, & Общее время \\
           & переходов, \% & распределения, \% & сек            & работы, сек                 \\ \hline
    1      & 16                  & \textbf{66.3}     & 29             & 43                  \\ \hline
    2      & 36                  & 12.8              & 65             & 84                  \\ \hline
    ---    & \textbf{87}         & 0.1               & \textbf{127}   & \textbf{164}        \\ \hline
  \end{tabular}
  \caption{Сравнение распределений (алгоритм выбора лидера)}
  \label{tab:election-results}
\end{table}

\begin{table}[htb]
  \centering
  \begin{tabular}{|c|c|c|c|c|}
    \hline
    $\rho$ & Доля внешних        & Неравномерность   & Время простоя, & Общее время \\
           & переходов, \% & распределения, \% & сек            & работы, сек         \\ \hline
    1      & 17                  & \textbf{89.4}     & 3              & 14                  \\ \hline
    2      & 35                  & 29.6              & 7              & 21                  \\ \hline
    ---    & \textbf{88}         & 0.1               & \textbf{50}    & \textbf{75}         \\ \hline
  \end{tabular}
  \caption{Сравнение распределений (<<обедающие философы>>)}
  \label{tab:philo-results}
\end{table}


Проблемные значения выделены жирным начертанием. В таблицах приведены следующие величины:

\begin{itemize}
\item доля вызовов среди переходов~--- отношение числа удаленных вызовов (суммарно на всех узлах) к числу переходов $T$;
\item неравномерность распределения~--- отношение среднеквадратичного отклонения к среднему для последовательности $m_1
  m_2 \ldots m_N$, где $m_i$~--- число состояний, хранимых узлом $i$;
\item время простоя при ожидании сообщений от других узлов (сетевые задержки);
\item общее время работы.
\end{itemize}

Из приведённых результатов можно сделать следующие выводы.

\begin{enumerate}
\item Выбор распределения между узлами важен, поскольку время простоя за счет удаленных вызовов составляет существенного
  часть от времени выполнения.

\item При <<наивном>> подходе к распределению состояний число удаленных вызовов близко к числу всех переходов, как и следует из~\eqref{eq:rpc-partfull}.

\item Предлагаемый способ распределения состояний по первым $\rho$ процессам позволяет уменьшить число удаленных вызовов
  и время выполнения в сравнении с <<наивным>> подходом в соответствии с~\eqref{eq:rpc-partproc}.

\item Необходим подбор параметра $\rho$ в соответствии со свойствами проверямой модели ($P, w_i$) для обеспечения
  требуемого уровня равномерности распределения состояний; в частности, значения $\rho = 1$ в приведенных экспериментах
  оказалось недостаточно, поскольку неравномерность до 90\% означает, что большая часть памяти некоторых узлов не
  используется вообще.
\end{enumerate}

\section{Выводы}
\label{sec:conclusion}

Использование параллельной генерации состояний дискретных детерминированных моделей при проверке их соответствия спецификациям позволяет выполнять верификацию моделей на несколько порядков большего размера, чем позволяют аналогичные подходы с последовательной генерацией.
Одним из наиболее важных факторов является функция распределения хранимых состояний между узлам, правильный выбор которой, как подтверждают эксперименты, позволяет существенно ускорить проверку утверждений.

\end{document}

