\documentclass[a4paper,12pt,notitlepage]{article}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{textcomp}
\usepackage{indentfirst}
\usepackage{verbatim}

\sloppy

\title{Параллельное построение пространства состояний конечной системы}
\author{Коротков И.А.}
\date{2010 г.}

\begin{document}

\maketitle

При разработке параллельных алгоритмов и протоколов взаимодействия
часто возникает необходимость их верификации на соответствие
определённым условиям целостности. Например, параллельный алгоритм
не должен иметь взаимоблокировок, а в протоколе взаимодействия все
участвующие стороны должны всегда достигать конечного состояния.

Функциональное тестирование системы позволяет выявить не все ошибки, а
лишь наиболее часто встречающиеся. В то же время, определённые классы
ошибок требуется полностью исключить. Для их выявления и
подходит верификация самой модели, которая путем перебора всех
состояний системы проверит, возможен ли такой сценарий
функционирования системы, при котором она приходит в недопустимое
состояние.

Сущестует большое количество программных средств верификации конечных
моделей, наиболее универсальным и распространенным из которых является
SPIN. Он и будет использоваться в качестве основы для дальнейшей
работы. Для описания моделей в верификаторе SPIN используется язык
описания Promela.

Верификатор SPIN принимает в качестве входных данных модель на языке
PROMELA и генерирует файл с кодом на языке С. Полученный код выполняет
исчерпывающий поиск в глубину по пространству состояний, добавляя
новые состояния в хэш-таблицу состояний. 

Поскольку размер пространства состояний модели растет экспоненциально,
даже для среднего размера моделей оно насчитывает до $10^9~-~10^{10}$
состояний, требующих десятки гигабайт памяти для хранения множества
пройденных состояний. Это делает проверку больших моделей
нереализуемой практически. Для сокращения объема требуемой памяти
используются различные оптимизации — сжатие хранимых состояний,
битовое хэширование пространства состояний и т.д. В данной работе
предлагается другой подход — параллельное выполнение на нескольких
узлах вычислительной сети с распределением хранимых состояний между
ними.

Возможны два варианта параллельной генерации состояний:

\begin{enumerate}
\item Распределенное хранилище состояний. Состояния генерирует только
  один узел, а для хранения используются все узлы. Каждое состояние
  имеет свой однозначно вычислимый номер узла. Преимуществом данного
  подхода является возможность по-прежнему использовать поиск в
  глубину, необходимый для поиска циклов. Недостаток заключается в
  том, что каждое новое состояние требует удаленного вызова (обращения
  к другому узлу) для проверки, было ли он уже достигнуто.

\item Распределенная генерация состояний. Каждый узел является
  одновременно хранилищем и генератором. Этот вариант предпочтителен,
  поскольку используется вычислительная мощность всех узлов и
  сокращается число удаленных вызовов за счет тех случаев, когда новое
  состояние принадлежит тому же самому узлу. Хотя каждый узел может
  выполнять с локальной точки зрения поиск в глубину, глобальный
  порядок достижения состояний нарушается, и поиск циклов становится
  затруднителен. Зачастую верификация модели требует лишь
  проверки корректности конечных состояний и выполнения инвариантов, а
  в этом случае поиск циклов не требуется, что позволяет использовать
  в данном варианте обычный поиск в ширину.
\end{enumerate}

Для отображения состояний на узлы используется некая функция, которая
должна обладать следующими условиями:

\begin{itemize}
\item она должна зависеть только от самого состояния, поскольку одно и
  то же состояние может генерироваться различными узлами в результате
  различных переходов;

\item она должна по возможности распределять состояния между узлами
  равномерно;

\item она должна обладать определенной локальностью — по возможности
  новые состояния должны принадлежать тому же узлу, что и исходное,
  для уменьшения числа удаленных вызовов.
\end{itemize}

Наиболее простым подходом является использование для этой цели
хэш-функции от всего состояния. Это обеспечит первые 2 условия: если
выбрана подходящая хэш-функция, распределение будет достаточно
равномерным. Однако, третье условие при этом не соблюдается, поскольку
все новые состояния имеют равные шансы принадлежать любому узлу
независимо того, на каком узле они были сгенерированы.

В данной работе предлагается для распределения состояний по узлам
хэшировать не все состояние целиком, а лишь локальное состояние одного
процесса. В этом случае удаленный вызов будет происходить лишь при
переходах, изменяющих локальное состояние этого процесса.

Был создан прототип системы, имитирующий параллельную генерацию
состояний с распределенным хранением. Данный прототип состоит из
транслятора, разбирающего модель на языке PROMELA, и генератора
состояний на языке С.

В качестве модели использовалась модель задачи об обедающих философов
для случаев $P = 5, 6, \text{ и } 7$ философов. В качестве функции
отображения используются оба варианта: хэш-функция от всего состояния
и от состояния первого процесса.

Результаты экспериментов для имитации ЛВС из 4 узлов представлены на
слайде. В столбцах <<Состояния>> и <<Переходы>> указано общее число
состояний и переходов модели. В столбце <<Удаленные вызовы>> -- число
(суммарное по всем узлам) удаленных вызовов за время имитации; слева
от <</>> -- при использовани хэш-функции от всего состояния, справа --
от состояния одного процесса. в столбце <<Загруженность узлов>> в
качестве меры <<равномерности>> распределения состояний между узлами
показано отношение минимального и максимального объема используемой
памяти среди всех узлов.

Из приведенных выше результатов можно сделать следующие выводы:

\begin{enumerate}
\item При использовании в качестве функции отображения хэша всего
  состояния число удаленных вызовов приближается к числу всех
  переходов, что делает ее крайне неэффективной по скорости работы,
  однако позволяет более равномерно использовать память узлов.

\item Использование вместо нее хэша от состояния только одного
  (первого) процесса приводит к значительному сокращению числа
  удаленных вызовов.

\item Равномерность распределения состояний между узлами падает в последнем
  случае, что приводит к простою части памяти  (до 30\% на некоторых узлах),
  поэтому возможно дальнейшее улучшение функции распределения.
\end{enumerate}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
