\documentclass[a4paper,notitlepage,14pt]{article}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{textcomp}
\usepackage{indentfirst}
\usepackage{verbatim}

\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}

\usepackage{hyperref}

\usepackage{graphicx}

%\usepackage[left=20mm,right=20mm,top= 0mm,bottom=20mm]{geometry}

\usepackage{listings}
\lstset{
  basicstyle=\footnotesize,
  frame=none,
  breakatwhitespace=true,% разрыв строк только на whitespacce
  breaklines=true,       % переносить длинные строки
  captionpos=b,          % подписи снизу
  numbers=none,          % без нумерации
  showspaces=false,      % показывать пробелы подчеркиваниями -- идиотизм 70-х годов
  showstringspaces=false,
  showtabs=false,        % и табы тоже
  stepnumber=1,
  tabsize=4              % кому нужны табы по 8 символов?..
}

\sloppy
\hyphenpenalty=9000

\makeatletter
\renewcommand\@biblabel[1]{\hfill#1.}
\makeatother

\title{Параллельная верификация формул логики ветвящегося времени на дискретных
  детерминированных моделях моделях} \author{Коротков\,И.\,А.}

\begin{document}

\maketitle

\emph{Проверка на модели} (model checking)~--- это автоматический метод верификации
параллельных систем с конечным числом состояний.~\cite{Clarke}.

При разработке сложных параллельных систем (систем, состоящих из нескольких асинхронно
функционирующих компонент) с высокой степенью надежности традиционных подходов к
тестированию зачастую бывает недостаточно~\cite{Clarke}, поскольку они позволяет выявить
лишь часто воспроизводимые ошибки. Проверка на модели применяется в случаях, когда
требуется полностью исключить определенные классы ошибок~--- например, в программном
обеспечении бортовых систем~\cite{Havelund98formalanalysis,CamaraArincModel}, сетевых
протоколов~\cite{RipOnSpin}, электронных схем микрочипов~\cite{Glazberg_psl:beyond} и т.п.

В ходе проверки на модели на основе дискретной детерминированной модели программы или
комплекса программ строится полное пространство состояний и на нем проверяется набор
интересующих нас утверждений~--- спецификация~\cite{Velder}. Основной проблемой,
возникающей при этом, является <<комбинаторный взрыв>> числа состояний
системы\cite{Clarke}.

Примером использования проверки на модели является доказательство необходимости добавления
в протокол маршрутизации RIP расширения, называемого <<расщепленный
горизонт>>~\cite{Black00:IP}. Проверка модели сети из четырех маршрутизаторов, соединенных
четыремя сетевыми интерфейсами, на предмет возникновения циклов в маршрутных таблицах
позволяет убедиться, что без использования <<расщепленного горизонта>> существуют такие
сценарии, при которых циклы возникают.~\cite{RipOnSpin}

% !!!одним из преимуществ проверки на модели является то, что она всегда завершается за
% конечное время с ответом <<да>> или <<нет>>.

\section{Формализация конечной модели}
\label{sec:modelchecking}

\subsection{Структуры Крипке}
\label{sec:kripke}

Пространство состояний моделируемой программы или программного комплекса можно
формализовать, как модель Крипке (структуру Крипке, Kripke
structure)~\cite{Clarke}. Моделью Крипке $M$ над множеством атомарных высказываний $AP$
называют четверку $(S, S_0, R, L)$, где:

\begin{itemize}
\item $S$~--- конечное множество состояний;
\item $S_0 \in S$~--- множество начальных состояний;
\item $R \in S \times S$~--- отношение переходов, которые обязано быть тотальным, т.е. для
  каждого состояния $s \in S$ должно существовать такое состояние $s' \in S$, что имеет
  место $R(s, s')$;
\item $L\colon S \rightarrow 2^{AP}$~--- функция, которая помечает каждое состояние
  множеством атомарных высказываний, истинных в этом состоянии.
\end{itemize}

Путь в модели $M$ из состояния $s$~--- это бесконечная последовательность состояний $\pi =
s_0 s_1 \ldots$, такая, что $s_o = s$ и для всех $i \geq 0$ выполняется $R(s_i, s_{i+1})$.

Моделируемый программный комплекс в каждом своем состоянии описываются набором значений
переменных $V = \{v_0, v_1, \ldots\}$, принимающих значения на конечном множестве $D$
(домене интерпретации) и описывающих отдельные компоненты и взаимодействие между
ними. Множество $AP$ состоит из утверждений вида $v_i = d_i$, где $d_i \in D$. Таким
образом, каждое состояние $s$ в $M$ представляет собой отображение $V \rightarrow D$.

Отношение $R$ определяется следующим образом. Пусть имеются два состояния, $s_1$ и
$s_2$. Если в $s_1$ имеется компонент, который может выполнить атомарный переход
(изменение значений своих переменных), в результате выполнения которого система будет
находиться в состоянии $s_2$, тогда состояния $s_1$ и $s_2$ связаны отношением перехода:
$(s_1, s_2) \in R$. В случае, если нет такого состояния $s_2$, для которого бы выполнялось
$R(s_1, s_2)$, полагается $R(s_1, s_1)$, т.е. <<тупиковое>> состояние связано отношение
перехода само с собой.

\subsection{Двоичные диаграммы принятия решений}
\label{sec:obdd}

Альтернативным способом представления модели являются упорядоченные двоичные диаграммы
принятия решений (\emph{ordered binary decision diagram}, OBDD)!!!. 

!!! определение !!!

Модель описывается при помощи OBDD следующим образом 

!!! описание R(...) <=> f(...) = 1 !!!

\section{Формализация спецификации модели}
\label{sec:specification}

\subsection{Виды условий спецификации}
\label{sec:cond-types}

!!! safety/liveness

Существует несколько способов формализации спецификации верифицируемой модели:
темпоральные логики, к которым относятся: логика линейного времени LTL (linear time
logic)~\cite{Clarke,Stirling96modaland}, логика ветвящего времени CTL (computation tree
logic)~\cite{Clarke,Pandya01modelchecking}, CTL* (объединение LTL и CTL), логика
переменного времени ATL (alternating time logic)~\cite{Stirling96modaland}, логика
расширенного времени ETL (extended time logic)~\cite{Emerson90temporaland};
мю-исчисление~\cite{Leucker_parallelmodel,Emerson97modelchecking}; язык спецификации
утверждений PSL~\cite{Glazberg_psl:beyond}.

Одной из наиболее выразительных и при этом удобной для понимания~\cite{Stirling96modaland}
является CTL*, объединяющая в себе логику линейного и ветвящегося времени.

\subsection{Временные логики}
\label{sec:temporal-logics}

Темпоральные (временные) логики позволяют описывать последовательности переходов между
состояниями системы. В перечисленных логиках, несмотря на название, время напрямую
неиспользуется; вместо этого используются утверждения, что некоторое состояние
\emph{когда-либо будет} достигнуто или что оно \emph{никогда не будет} достигнуто. Такие
утверждения записываются при помощи \emph{темпоральных операторов}, которые можно
объединять булевыми связками. Между собой темпоральные логики отличаются в основном
набором доступных операторов.

Формулы в CTL* составляются из атомарных утверждений, темпоральных операторов и
\emph{кванторов пути}. В CTL* имеется два квантора:

\begin{itemize}
\item $\mathbf{A}$ (all)~--- <<для всех путей, выходящих из данного состояния>>,
\item $\mathbf{E}$ (exists)~--- <<существует такой путь, выходящий из данного состояния>>
\end{itemize}

\noindent и 5 операторов:

\begin{itemize}
\item $\mathbf{F}$ (finally)~--- <<рано или поздно в пути встретится состояние, в котором
  выполняется указанное утверждение>>,
\item $\mathbf{G}$ (globally)~--- <<во всех состояниях пути выполняется указанное
  утверждение>>,
\item $\mathbf{X}$ (next)~--- <<в следующем состояния пути выполняется указанное
  утверждение>>,
\item $\mathbf{U}$ (until)~--- <<пока в пути не появится состояние, в котором выполняется
  второе утверждение, во всех состояниях должно выполняться первое утверждение>>.
\end{itemize}

Например, формула $\mathbf{AFG}~ x$ означает <<во всех путях, идущих из начального
состояния, с некоторого состояния на протяжении всего пути выполняется $x$>>, а формула
$\mathbf{AGEF}~ x$ означает <<во всех путях, идущих из начального состояния, из каждого
состояния есть хотя бы один путь, в котором рано или поздно встретится состояние, в
котором выполняется $x$>>.

В CTL* выделяют два собственных пересекающихся подможества: логику линейного времени LTL и
логику ветвящегося времени CTL, объединение которых составляет саму CTL*. Различие между
ними заключается в допустимых комбинациях кванторов пути и темпоральных операторов. 

Логика линейного времени LTL состоит из формул вида $\mathbf{A}~f$, где $f$ не содержит
кванторов пути, только атомарные утверждения и темпоральные операторы. Примерами
LTL-формул являются $\mathbf{F}~x~\mathbf{U}~y$, $\mathbf{G}~x \Rightarrow \mathbf{F}~y$
($\mathbf{A}$ в начале обычно опускается).

Логика ветвящегося времени CTL состоит из формул, где кванторы пути чередуются с
темпоральными операторами (т.е. перед каждым темпоральным оператором должен стоять квантор
пути). Примерами CTL-формул являются $\mathbf{AG}~\mathbf{EF}~x$, $\mathbf{AG} x
\Rightarrow \mathbf{EF} y$.

Можно сказать, что LTL-формулы представляют собой утверждения относительно событий,
происходящих на каждом возможном пути в модели $M$, отсюда название <<логика
\emph{линейного} времени>>. В то же время, CTL-формулы представляют собой утверждения о
наличии выбора пути в определенных состояниях, приводящего к желаемому
результату.~\cite{Clarke}

На практике CTL используется чаще, чем LTL!!!ссылка!!!. Однако, у CTL имеется существенный
недостаток: невозможность выразить так называемые условия <<сильной
справедливости>>.~\cite{Katoen,DBLP:conf/spin/FaragoS09} Условия <<слабой справедливости>>
имеющие вид $\mathbf{AGF}~P$ (<<на каждом пути бесконечно часто встречается состояние, в
котором выполняется $p$>>) выразимы эквивалентной CTL-формулой $\mathbf{AF~AG}~p$. В то же
время условия <<сильной справедливости>>, имеющие виде $\mathbf{AG} (p \Rightarrow
\mathbf{F} q)$ (<<на каждом возможном пути после состояния, в котором выполняется условие
$p$, рано или поздно встретится состояние, в котором выполняется условие $q$>>), не имеет
эквивалентной CTL-формулы.

Это делает невозможным проверку утверждений типа <<за запросом всегда рано или поздно
следует ответ>>. Данный недостаток CTL решается его модификацией~--- fairness CTL (логика
ветвящего времени с условиями <<справедливости>>). Формулы FCTL представляют из себя
обычные CTL-формулы, однако добавляется ограничение: все пути в структуре Крипке должны
быть <<справделивыми>>. <<Справедливым>> считается путь $\pi = s_0s_1\ldots$, такой, что
для бесконечно большого числа $i$ выполняется $s_i \in F$, где $F \in S$~--- некое
подмножество состояний. Иными словами, каждый путь в FCTL должен бесконечное число раз
проходить через состояния из определенного множества $F$.

Проверка как LTL, так и CTL-формул принадлежит к классу сложности PSPACE!!! и линейна по
число состояний!!!. Однако, на практике проверка CTL-формул менее затратна: сравнение в
!!! показывает, что на проверку LTL-формул уходит в два раза больше времени и объема
памяти, чем на проверку аналогичной по выразительной мощности CTL-формуле. Кроме того,
проверка CTL-формул имеет линейную сложность по длине формулы, а LTL-формул~---
экспоненциальную, что делает CTL более привлекательным в практических задачах.

Оказывается, что большая часть LTL-формул!!! может быть сведена к CTL-формулам с условиями
<<справедливости>>.
!!! [14][17]

!!! упомянуть про схождесть с бьюхи

\subsection{\mu-исчисление}
\label{sec:mu-calculus}

!!! можно сюда пихнуть про мю-исисчление

\section{Существующие средства проверки на модели}
\label{sec:existing-tools}

!!!сам алгоритм проверки формул

!!! символьная верификация

!!! пояснить где-то про проверку on-the-fly и глобальную

Существует большое количество программных средств для проверки на модели, наиболее
универсальным и распространенным из которых является ПО \Code{Spin}~\cite{SpinRoot},
разработнное Дж. Хольцманом в Bell Labs в 1980. Для описания моделей в ПО Spin
используется язык описания \Code{Promela} (PROtocol Meta Language).

Другим известным средством проверки на модели является
\Code{NuSMV}~\cite{Cimatti00nusmv:a}, использующий в качестве языка описания SMV (Symbolic
Model Verification) и Mur\phi~\cite{Dill96murphi}.

!!! Murhpi
!!! EUCLID

\section{Проблема роста числа состояний}
\label{sec:state-explosion}

Последовательное построение пространства состояний $S$ с ростом размера модели быстро
становится невозможным из-за нехватки ОЗУ для хранения множества достигнутых состояний. В
табл.~\ref{tab:models-statecount} приведены данные для двух моделей: модели задачи об
обедающих философов и приведенной выше в качестве примера модели RIP-протокола на четырех
сетевых маршрутизаторах.

\begin{table}
  \centering
  \begin{tabular}{|r|l|l|}
    \hline
    Модель                  & Состояний         & Переходов       \\
    \hline
    Философы (5)            & $2.8 \cdot 10^4$  & $4.2 \cdot 10^4$ \\
    Философы (7)            & $3.6 \cdot 10^5$  & $6.0 \cdot 10^5$ \\
    RIP (4 маршрутизатора)  & $1.6 \cdot 10^8$  & $4.8 \cdot 10^9$ \\
    \hline
  \end{tabular}
  \caption{Количество состояний и переходов в различных моделях}
\label{tab:models-statecount}
\end{table}

Из табл.~\ref{tab:models-statecount} видно, что для реальных моделей традиционный подход к
генерации пространства состояний поиском в глубину или ширину становится проблематичен: к
примеру, модель RIP-протокола с 5-ю маршрутизаторами потребует уже более 100 Гб
оперативной памяти для хранения пространства состояний.

Существует ряд подходов, решающих данную проблему. Среди них можно выделить:

\begin{itemize}
\item хранение состояний во внешней памяти~--- данный подход практически никогда не
  применяется, так как время верификации возрастает на несколько порядков~\cite{Clarke};
\item методы оптимизации, уменьшающие количество генерируемых и хранимых состояний:
  сокращение частных порядков~\cite{POD};
\item методы оптимизации, уменьшающие расход памяти на хранение пространства состояний:
  сжатие битового представления состояния кодами хаффмана~\cite{StateCompr}, рекурсивное
  кодирование состояний~\cite{StateCompr}, битовое хэширование без проверки
  коллизий~\cite{BitHash1,Wolper}.
\end{itemize}

Недостаток вышеперечисленных методов в том, что они дают ограниченный, плохо
масштабируемый прирост числа состояний, которые возможно хранить, в обмен на уменьшение
скорости (сжатие состояний) или <<потерю>> части состояний (битовое хэширование без
проверки коллизий).

Альтернативным решением проблемы роста состояний является использование средств
параллельных вычислений для распределения хранимых состояний между несколькими узлами
вычислительной сети.

\section{Существующие работы по данному направлению}
\label{sec:other-work}

Первые работы по параллелизации генерации состояний!!!ссылка!!! появились еще в 87~г. Они
имели ряд недостатков: !!!

В !!! предлагается параллельная версия верификатора Mur\phi, использующая параллельный
обход графа сосотяний в ширину с равномерным распределением состояний между узлами. Одним
из принципиальных недостатков этого подхода быао большое количество пересылаемых между
узлами сообщений, содержащих новые состояния. Авторы предлагали в качестве решения
проблемы буферизацию сообщений при отправке.

В ~\cite{LS99} предлагается иной подход: распределение сосотяний, обладающее одновременно
свойствами равномерности и локальности, что позволило уменьшить число передаваемых
сообщений.

В !!! предлагается также идея параллельного хранения и обработки OBDD, кроме того, попытки
параллельного хранения OBDD предпринимались в ходе разработке параллельной версии
Mur\phi!!!, однако, оказались неуспешны.

Перечисленные работы решали лишь задачу параллельной генерации и хранения пространства
состояний. При этом также возможна проверка условий <<безопасности>>, которая сводится к
отсутствию состояний, в которых выполняются определенные условия. Однако, проверка условий
<<живости>>, (CTL*-формул) при этом не рассматривалась.

Главная сложность проверки CTL*-формул на модели заключается в необходимости \emph{поиска
  циклов} и повторной их проверки. Обнаружение циклов легко осуществимо при поиске в
глубину (алгоритм <<nested DFS>>, !!!), но при параллельной генерации сосотяний какой-либо
глобальный порядок обхода состояний отсутсвует и поиск циклов затруднен.

В университете Брно опубликован ряд работ~\cite{DLTL1,DLTL2}, в которых рассматривается
параллельная проверка условий <<живости>>, заданных в виде LTL-формул. На основе этих
работ в 2005~г. авторами был разработан программный продукт \texttt{DiVinE}~\cite{DiVinE}.

Авторами \texttt{DiVinE} используется несколько подходов, включая выбор функции
распределения состояний, которая приводит к локализации всех циклов в пределах одного
узла~\cite{DLTL1}, и параллельное обнаружение циклов с последующей последовательной
проверкой~\cite{DLTL2}.

В !!! предложен алгоритм параллельной раскраски графа, позволяющий выполнять параллельную
проверку формул \mu-исчисления первого и второго порядка, которые эквивалентны
CTL*. Однако, предложенный там подход неполон и требует доработки. В частности, не
рассматривается способ эффективного параллельного разбиения графа на компоненты связности.

Таким образом, работы, имеющие практический результат, по параллельной проверке CTL-формул
на модели на данный момент отсутствуют. При том, что CTL является более распространенной и
вычислительно эффективной, чем LTL, данная задача является актуальной для современной
области формальной верификации.

\section{Проделанная работа}
\label{sec:my-work}

В!!!ссылка на себя!!! предложен способ распределений состояний при параллельной генерации,
позволяющий сократить в несколько раз число удаленных вызовов при генерации.

!!! как делается проверка: раскраска графа
!!! распределение состояний с целью уменьшить число пересылаемых сообщений

План в итоге:
+ Что такое MC
+ формализация: модель крипке
+ формализация: CTL, LTL, mu
- применение МС на практике, существующие средства
+ проблема роста числа состояний
- существующие работы по решению проблем
- проделанная мной работа
- план на дисер
- цель и задачи

\bibliographystyle{../thesis/gost780u}
\bibliography{../thesis/thesis}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

%%% Идеи
%%% 