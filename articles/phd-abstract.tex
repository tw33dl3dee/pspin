\documentclass[a4paper,notitlepage,14pt]{article}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{textcomp}
\usepackage{indentfirst}
\usepackage{verbatim}

\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}

\usepackage[
bookmarks=true, colorlinks=true, unicode=true,
urlcolor=black,linkcolor=black, anchorcolor=black,
citecolor=black, menucolor=black, filecolor=bla,
]{hyperref}

\usepackage{graphicx}

% Soviet style
\usepackage[left=35mm,right=20mm,top=20mm,bottom=20mm]{geometry}
\usepackage{setspace}
\onehalfspacing

\usepackage{listings}
\lstset{
  basicstyle=\footnotesize,
  frame=none,
  breakatwhitespace=true,% разрыв строк только на whitespacce
  breaklines=true,       % переносить длинные строки
  captionpos=b,          % подписи снизу
  numbers=none,          % без нумерации
  showspaces=false,      % показывать пробелы подчеркиваниями -- идиотизм 70-х годов
  showstringspaces=false,
  showtabs=false,        % и табы тоже
  stepnumber=1,
  tabsize=4              % кому нужны табы по 8 символов?..
}

\sloppy
\hyphenpenalty=9000

\makeatletter
\renewcommand\@biblabel[1]{\hfill#1.}
\makeatother

\title{Параллельная верификация формул логики ветвящегося времени на дискретных
  детерминированных моделях моделях} \author{Коротков\,И.\,А.}

\begin{document}

\maketitle

\textbf{Введение}. \emph{Проверка на модели} (model checking)~--- это автоматический метод верификации
параллельных систем с конечным числом состояний~\cite{Clarke}.

При разработке сложных параллельных систем (систем, состоящих из нескольких асинхронно
функционирующих компонент) с высокой степенью надежности традиционных подходов к
тестированию зачастую бывает недостаточно~\cite{Clarke}, поскольку они позволяет выявить
лишь часто воспроизводимые ошибки. Проверка на модели применяется в случаях, когда
требуется полностью исключить определенные классы ошибок~--- например, в программном
обеспечении бортовых систем~\cite{Havelund98formalanalysis,CamaraArincModel}, сетевых
протоколов~\cite{RipOnSpin}, электронных схем микрочипов~\cite{Glazberg_psl:beyond} и т.п.

В ходе проверки на модели на основе дискретной детерминированной модели программы или
комплекса программ строится полное пространство состояний и на нем проверяется набор
интересующих нас утверждений~--- спецификация~\cite{Velder}. Основной проблемой,
возникающей при этом, является <<комбинаторный взрыв>> числа состояний
системы\cite{Clarke}.

Примером использования проверки на модели является доказательство необходимости добавления
в протокол маршрутизации RIP расширения, называемого <<расщепленный
горизонт>>~\cite{Black00:IP}. Проверка модели сети из четырех маршрутизаторов, соединенных
четыремя сетевыми интерфейсами, на предмет возникновения циклов в маршрутных таблицах
позволяет убедиться, что без использования <<расщепленного горизонта>> существуют такие
сценарии, при которых циклы возникают~\cite{RipOnSpin}.

% !!!одним из преимуществ проверки на модели является то, что она всегда завершается за
% конечное время с ответом <<да>> или <<нет>>.

%%%%%%%%%%%%%%%%%%%% проблема и актуальность %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textbf{Проблема роста числа состояний}. Главной проблемой проверки на модели является
небходимость в процессе обхода графа состояний хранить множество посещенных состояний. С
ростом размера множество состояний $S$ проверка быстро становится невозможной из-за
нехватки ОЗУ для хранения множества посещенных состояний. В
табл.~\ref{tab:models-statecount} приведены данные для двух моделей: модели задачи об
обедающих философов и приведенной выше в качестве примера модели RIP-протокола на четырех
сетевых маршрутизаторах~\cite{RipOnSpin}~--- при их проверке на ПО \textbf{Spin}.

\begin{table}
  \centering
  \begin{tabular}{|r|l|l|}
    \hline
    Модель                  & Состояний         & Переходов       \\
    \hline
    Философы (5)            & $2.8 \cdot 10^4$  & $4.2 \cdot 10^4$ \\
    Философы (7)            & $3.6 \cdot 10^5$  & $6.0 \cdot 10^5$ \\
    RIP (4 маршрутизатора)  & $1.6 \cdot 10^8$  & $4.8 \cdot 10^9$ \\
    \hline
  \end{tabular}
  \caption{Количество состояний и переходов в различных моделях}
\label{tab:models-statecount}
\end{table}

Из табл.~\ref{tab:models-statecount} видно, что для реальных моделей традиционный подход к
генерации пространства состояний поиском в глубину или ширину становится проблематичен: к
примеру, модель RIP-протокола с 5-ю маршрутизаторами потребует уже более 100 Гб
оперативной памяти для хранения пространства состояний.

Существует ряд подходов, решающих данную проблему. Среди них можно выделить:

\begin{itemize}
\item хранение состояний во внешней памяти~--- данный подход практически не применяется,
  так как время верификации возрастает на несколько порядков~\cite{Clarke};
\item символьная верификация, при которой пространство Крипке не строится, а
  представляется в виде булевых формул, надо которыми выполняются дальнейшие
  преобразоваия~--- часто места на хранение преобразуемых булевых формул уходит не меньше,
  чем на хранение посещенных состояний~\cite{Stern97parallelizingthe};
\item методы оптимизации, уменьшающие количество генерируемых и хранимых состояний:
  сокращение частных порядков~\cite{POD};
\item методы оптимизации, уменьшающие расход памяти на хранение пространства состояний:
  сжатие битового представления состояния кодами хаффмана~\cite{StateCompr}, рекурсивное
  кодирование состояний~\cite{StateCompr}, битовое хэширование без проверки
  коллизий~\cite{BitHash1,Wolper}.
\end{itemize}

Недостаток вышеперечисленных методов в том, что они дают ограниченный, плохо
масштабируемый прирост числа состояний, которые возможно хранить, в обмен на уменьшение
скорости (сжатие состояний, внешняя память) или <<потерю>> части состояний (битовое
хэширование без проверки коллизий).

Альтернативным решением проблемы роста состояний является использование средств
параллельных вычислений для распределения хранимых состояний между несколькими узлами
вычислительной сети.

%%%%%%%%%%%%%%%%%%%%%%%%% состояние дел и обзор работ %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textbf{Существующие средства проверки на модели}. Существует большое количество
программных средств для проверки на модели.

ПО \textbf{Spin}~\cite{SpinRoot}, разработнное Дж. Хольцманом в Bell Labs в 1980,
использут для описания модели язык \textbf{Promela} (PROtocol Meta Language). Модель в
языке Promela представляется в виде набора взаимодействующих чрез каналы и глобальные
переменные конечных автоматов~--- процессов. Модель представляет собой пространство
состояний КА, получающегося в результате пересечения КА всех процессов, входящих в
модель. ПО \textbf{Spin} поддерживает проверку условий <<надежности>> в виде утверждений
(\emph{assert}) и условий <<живости>>, заданных формулами логики линейного времени
(см. далее).

При проверке на модели \textbf{SPIN} совмещает генерацию состояний с проверкой
утверждений. Для проверки формул логики линейного времени вместо исходной структуры $M$
строится автомат Бьюхи $\Omega$ и, при обнаружении допускающего цикла, проверка
завершается с отрицательным результатом. Для генерации состояний используется обход графа
в глубину с вложенным обходом в глубину для поиска циклов~\cite{DBLP:conf/spin/FaragoS09}.

Другим широко распространенным средством проверки на модели является
\textbf{NuSMV}~\cite{Cimatti00nusmv:a}, использующий в качестве языка описания SMV
(Symbolic Model Verification). \textbf{NuSMV} использует внутренне представление модели в
виде OBDD и символьную верификацию. В качестве языка спецификаций поддерживается fairness
CTL.

Другим примером ПО, использующего символьную верификацию, является система \textbf{UCLID},
модель в которой задается при помощи счетной арифметики с лямбда-выражениями и
неинтерпретированными функциями (\emph{Counter Arithmetic with Lambda Expressions and
  Uninterpreted Functions}, CLU)~\cite{Lahiri02modelingand}. ПО \textbf{UCLID}
используется для проверки моделей микропроцессоров, при этом вместо перебора всех
возможных состояний применяется математическое доказательство булевых формул.

ПО \textbf{Mur$\phi$}~\cite{Dill96murphi}, созданное для проверки алгоритмов кэширования в
мультипроцессорных системах~\cite{Dill96murphi}, во многом аналогично ПО \textbf{Spin}:
используется локальная проверка на модели, генерация состояний осуществляется путем обхода
графа в глубину. Однако, в \textbf{Mur$\phi$} поддерживаются лишь условия <<надежности>>.

\textbf{Обзор работ по данному направлению}. Первые работы по параллелизации
генерации состояний~\cite{Aggarwal87} появились еще в 87~г. Они имели ряд недостатков,
отмеченных в~\cite{Stern97parallelizingthe}.

В~\cite{Stern97parallelizingthe} предлагается параллельная версия верификатора
\textbf{Mur$\phi$}, использующая параллельный обход графа сосотяний в ширину с равномерным
распределением состояний между узлами. Одним из принципиальных недостатков этого подхода
быао большое количество пересылаемых между узлами сообщений, содержащих новые
состояния. Авторы предлагали в качестве решения проблемы буферизацию сообщений при
отправке.

В~\cite{LS99} предлагается иной подход: распределение состояний, обладающее одновременно
свойствами равномерности и локальности, что позволило уменьшить число передаваемых
сообщений и, как следствие, время простоя узлов при ожидании/отправке сообщений. В итоге
это позволило ускорить проверку на ряде моделей в 5--10 раз. Следует отметить, что
использование буферизации возможно и в данном случае.

% !!! неверная ссылка
В~\cite{McMillan92} рассмотрена идея параллельного хранения и обработки OBDD, кроме того,
попытки параллельного хранения OBDD предпринимались в ходе разработке параллельной версии
\textbf{Mur$\phi$}, однако, оказались неуспешны, и впоследствии авторы отказались от них,
используя подход, аналогичный~\cite{LS99}.

Перечисленные работы решали лишь задачу параллельной генерации и хранения пространства
состояний. При этом возможна проверка условий <<безопасности>>, т.е. проверка истичнности
некоторого утверждения $f(s)$ во всех состояниях. Однако, проверка условий <<живости>>,
при этом не рассматривалась.

Главная сложность проверки CTL*-формул (условий <<живости>>) на модели заключается в
необходимости поиска сильно связных компонент в графе состояний, требующем \emph{поиска
  циклов}. Обнаружение циклов легко осуществимо при поиске в глубину (алгоритм <<nested
DFS>>~\cite{DBLP:conf/spin/FaragoS09}), но при параллельной генерации сосотяний какой-либо
глобальный порядок обхода состояний отсутсвует и поиск циклов затруднен.

В университете Брно опубликован ряд работ~\cite{DLTL1,DLTL2}, в которых рассматривается
параллельная проверка условий <<живости>>, заданных в виде LTL-формул. На основе этих
работ в 2005~г. авторами был разработан программный продукт \texttt{DiVinE}~\cite{DiVinE}.

Авторами \texttt{DiVinE} используется несколько подходов. Один из них заключается в выборе
функции распределения состояний, которая приводит к локализации всех циклов в пределах
одного узла~\cite{DLTL1}, в результате чего поиск циклов проводится лишь локально. Другой
алгоритм представляет собой параллельное обнаружение циклов с последующей (дорогостояющей)
последовательной проверкой~\cite{DLTL2}.

В~\cite{Leucker_parallelmodel} предложена параллельная версия алгоритма проверки формул
$\mu$-исчисления глубины не более двух, к которым могут быть сведены формулы CTL*. Однако,
предложенный подход неполон и требует доработки. В частности, не рассматривается способ
эффективного параллельного разбиения графа на компоненты связности.

\textbf{Проделанная работа по данной теме}. В~\cite{Korotkov10Miem} автором разработан
метод параллельной генерации состояний, схожий с~\cite{LS99,Stern97parallelizingthe} и
была предложена функция распределения состояний между хранящими их узлами при параллельной
генерации моделей на языке Promela, которая позволяет сократить в несколько раз число
удаленных вызовов между узлами.

В предложенной функции распределения используется свойство локальности модели относительно
процессов Promela. К удаленному вызову приводят лишь те переходы, в которых меняет свое
состояние один из процессов, что позволило сократить время проверки и время простоя узлов
в несколько раз при сохранении достаточной равномерности (до 30\%) распределения состояний
между узлами.

%%%%%%%%%%%%%%%%%%%%%%%%%%%% актуальность %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textbf{Актуальность}. Работы, имеющие практический результат, по параллельной проверке
CTL-формул на модели на данный момент отсутствуют. При том, что CTL является более
распространенной и вычислительно эффективной (см. далее), чем LTL, данная задача является
актуальной для современной области формальной верификации.

%%%%%%%%%%%%%%%%%%%%%%% предполагаемые цели и задачи %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textbf{Цель и задачи будущей работы}. Целью дальнейшей работы является расширение
описанного в~\cite{Korotkov10Miem} подхода с целью параллельной проверки спецификаций в
виде формул ветвящейся логики.

Для достижения поставленной цели необходимо решить следующие задачи:

\begin{itemize}
\item проанализировать применимость существующих методов проверки CTL-формул при
  параллельной генерации состояний;
\item разработать метод, позволяющий выполнять параллельную проверку CTL-формул;
\item расширить данный метод на проверку условий справедливости;
\item модифицировать предложенную в~\cite{Korotkov10Miem} функцию распределения состояний
  для уменьшения числа удаленных вызовов;
\item на основе разработанного метода разработать средство параллельной проверки
  CTL-формул на моделях.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%% теоретический обзор %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textbf{Формализация конечной модели}.

\textit{Структуры Крипке}. Пространство состояний моделируемой программы или программного
комплекса можно формализовать, как модель Крипке (структуру Крипке, Kripke
structure)~\cite{Clarke}. Моделью Крипке $M$ над множеством атомарных высказываний $AP$
называют четверку $(S, S_0, R, L)$, где:

\begin{itemize}
\item $S$~--- конечное множество состояний;
\item $S_0 \in S$~--- множество начальных состояний;
\item $R \in S \times S$~--- отношение переходов, которые обязано быть тотальным, т.е. для
  каждого состояния $s \in S$ должно существовать такое состояние $s' \in S$, что имеет
  место $R(s, s')$;
\item $L\colon S \rightarrow 2^{AP}$~--- функция, которая помечает каждое состояние
  множеством атомарных высказываний, истинных в этом состоянии.
\end{itemize}

Путь в модели $M$ из состояния $s$~--- это бесконечная последовательность состояний $\pi =
s_0 s_1 \ldots$, такая, что $s_o = s$ и для всех $i \geq 0$ выполняется $R(s_i, s_{i+1})$.

Моделируемый программный комплекс в каждом своем состоянии описываются набором значений
переменных $V = \{v_0, v_1, \ldots\}$, принимающих значения на конечном множестве $D$
(домене интерпретации) и описывающих отдельные компоненты и взаимодействие между
ними. Множество $AP$ состоит из утверждений вида $v_i = d_i$, где $d_i \in D$. Таким
образом, каждое состояние $s$ в $M$ представляет собой отображение $V \rightarrow D$.

Отношение $R$ определяется следующим образом. Пусть имеются два состояния, $s_1$ и
$s_2$. Если в $s_1$ имеется компонент, который может выполнить атомарный переход
(изменение значений своих переменных), в результате выполнения которого система будет
находиться в состоянии $s_2$, тогда состояния $s_1$ и $s_2$ связаны отношением перехода:
$(s_1, s_2) \in R$. В случае, если нет такого состояния $s_2$, для которого бы выполнялось
$R(s_1, s_2)$, полагается $R(s_1, s_1)$, т.е. <<тупиковое>> состояние связано отношение
перехода само с собой.

\textit{Двоичные разрешающие диаграммы}. Альтернативным способом представления модели
являются упорядоченные двоичные разрешающие диаграммы (\emph{ordered binary decision
  diagram}, OBDD)\cite{Clarke}~--- форма представления булевых функций.

Двоичная разрешающая диаграмма представляет собой ациклический ориентированный граф,
вершины которого разбиты на два класса~--- терминальные и нетерминальные. Каждая
нетерминальная вершина $v$ помечена переменной $var(v)$ и имеет две вершины-последователя:
$low(v)$, соответствующую случаю, когда $var(v) = 0$, и $high(v)$, соответвествующую
случаю $var(v) = 1$. Каждая терминальная вершина помечена булевой величиной
$value(v)$. Одна из нетерминальных вершин является корневой.

Вычисление значения булевой функции сводится к обходу графа от корневой вершины до
терминальной в соответствии со значениями переменных. Значение функции определяется
$value(v)$ терминальной вершины. 

OBDD, как правило, дают значительно более компактное представление булевой функции, чем
таблицы истинности или СДНФ~\cite{Clarke}.

Модель Крипке $M = (S, R, L)$ может быть представлена при помощи OBDD следующим
образом. Пусть $\phi$~--- функция, отображающая состояния в булевы векторы $\phi: S
\rightarrow \{0, 1\}^m$ (при $|S| \leq 2^m$). Отношение $R(s, s')$ задается при помощи
OBDD для характеристической функции отношения $\widehat{R}(\phi(s), \phi(s'))$. Отношение
$L = AP \times S$ задается при помощи OBDD для характеристических функций множеств $L_p =
\{s~|~p \in L(s) \}$ для каждого $p \in AP$.

\textbf{Формализация спецификации модели.}

\textit{Виды условий спецификации}. Спецификация, соответствие которой проверяется для
данной модели, может включать в себя условия двух видов: условия <<безопасности>> (safety
conditions) и условия <<живости>> (livenes conditions).

Условия <<надежности>> (\emph{safety conditions})~--- утверждения, что <<не случится
ничего плохого>>. Примером может служить утверждение <<процессы не входят в состояние
взаимоблокировки>>. Все такие условия могут быть сведены~\cite{Clarke} к утверждению, что
ни в одном из путей $\pi$ модели $M$ ни одно состояние не удовлетворяет некоторому
предикату $f(s)$ относительно значений переменных в данном состоянии: $f(s) = f(v_i\|_s)$.

Условия <<живости>> (\emph{liveness conditions})~--- утверждения, что <<случится что-то
хорошее>>. Например, <<за каждым запросом будет рано или поздно следовать ответ>>. Данный
класс утверждений формализовать значительно сложнее. Многие условия <<живости>> могут
быть~\cite{Clarke97anotherlook} сведены к следующему утверждению: каждый путь $\pi$ в
модифицированный модели $M'$ содержит бесконечно много состояний, для которых выполняется
определенный предикат $f(s)$.

Существует несколько способов формализации условии <<живости>>: темпоральные (временные)
логики~\cite{Clarke,Pandya01modelchecking},
$\mu$-исчисление~\cite{Leucker_parallelmodel,Emerson97modelchecking}, язык спецификации
утверждений PSL~\cite{Glazberg_psl:beyond}.

Одним из наиболее выразительных и при этом удобным для понимания~\cite{Stirling96modaland}
способом являются темпоральные логики (temporal logics).

\textit{Темпоральные логики}. Темпоральные логики позволяют описывать последовательности
переходов между состояниями системы. В перечисленных логиках, несмотря на название, время
напрямую неиспользуется; вместо этого используются утверждения, что некоторое состояние
\emph{когда-либо будет} достигнуто или что оно \emph{никогда не будет} достигнуто. Такие
утверждения записываются при помощи \emph{темпоральных операторов}, которые можно
объединять булевыми связками. Между собой темпоральные логики отличаются в основном
набором доступных операторов. Далее рассматривается наиболее часто используемая временная
логика~--- CTL*~\cite{Stirling96modaland}.

В CTL* формулы составляются из атомарных утверждений, темпоральных операторов и
двух \emph{кванторов пути}:

\begin{itemize}
\item $\mathbf{A}$ (all)~--- <<для всех путей, выходящих из данного состояния>>,
\item $\mathbf{E}$ (exists)~--- <<существует такой путь, выходящий из данного состояния>>.
\end{itemize}

Темпоральных операторов в CTL* имеется пять:

\begin{itemize}
\item $\mathbf{F} f$ (finally)~--- <<рано или поздно в пути встретится состояние, в котором
  выполняется утверждение $f$>>,
\item $\mathbf{G} f$ (globally)~--- <<во всех состояниях пути выполняется утверждение
  $f$>>,
\item $\mathbf{X} f$ (next)~--- <<в следующем состояния пути выполняется утверждение
  $f$>>,
\item $f \mathbf{U} g$ (until)~--- <<рано или поздно в пути встретится состояние, в
  котором выполняется $g$; во всех состояниях до него должно выполняться $f$>>,
\item $f \mathbf{R} g$ (release)~--- <<$g$ должно выполняться во всех состояниях пути,
  пока не встретится состояние, в котором выполняется $f$>>.
\end{itemize}

Например, формула $\mathbf{AFG}~ f$ означает <<во всех путях, идущих из начального
состояния, с некоторого состояния на протяжении всего пути выполняется $f$>>, а формула
$\mathbf{AGEF}~ f$ означает <<во всех путях, идущих из начального состояния, из каждого
состояния есть хотя бы один путь, в котором рано или поздно встретится состояние, в
котором выполняется $f$>>.

В CTL* выделяют два собственных пересекающихся подможества: логику линейного времени
(linear time logic, LTL) и логику ветвящегося времени (computational tree logic, CTL),
объединение которых составляет само множество CTL*. Различие между ними заключается в
допустимых комбинациях кванторов пути и темпоральных операторов.

Логика линейного времени LTL состоит из формул вида $\mathbf{A}~f$, где $f$ не содержит
кванторов пути, только атомарные утверждения и темпоральные операторы. Примерами
LTL-формул являются $\mathbf{F}~x~\mathbf{U}~y$, $\mathbf{G}~x \Rightarrow \mathbf{F}~y$
($\mathbf{A}$ в начале обычно опускается).

Логика ветвящегося времени CTL состоит из формул, где кванторы пути чередуются с
темпоральными операторами (т.е. перед каждым темпоральным оператором должен стоять квантор
пути). Примерами CTL-формул являются $\mathbf{AG}~\mathbf{EF}~x$, $\mathbf{AG} x
\Rightarrow \mathbf{EF} y$.

Можно сказать, что LTL-формулы представляют собой утверждения относительно событий,
происходящих на каждом возможном пути в модели $M$, отсюда название <<логика
\emph{линейного} времени>>. В то же время, CTL-формулы представляют собой утверждения о
наличии выбора пути в определенных состояниях, приводящего к желаемому результату, отсюда
название <<логика \emph{ветвящегося} времени>>~\cite{Clarke}.

На практике CTL используется чаще, чем LTL~\cite{Stirling96modaland}. Однако, у CTL
имеется существенный недостаток: невозможность выразить так называемые условия <<сильной
справедливости>>~\cite{Katoen,DBLP:conf/spin/FaragoS09}. Условия <<слабой справедливости>>
имеющие вид $\mathbf{AGF}~P$ (<<на каждом пути бесконечно часто встречается состояние, в
котором выполняется $p$>>) выразимы эквивалентной CTL-формулой $\mathbf{AF~AG}~p$. В то же
время условия <<сильной справедливости>>, имеющие виде $\mathbf{AG} (p \Rightarrow
\mathbf{F} q)$ (<<на каждом возможном пути после состояния, в котором выполняется условие
$p$, рано или поздно встретится состояние, в котором выполняется условие $q$>>), не имеет
эквивалентной CTL-формулы.

Это делает невозможным проверку утверждений типа <<за запросом всегда рано или поздно
следует ответ>>. Данный недостаток CTL решается его модификацией~--- fairness CTL (логика
ветвящего времени с условиями <<справедливости>>). Формулы FCTL представляют из себя
обычные CTL-формулы, однако добавляется ограничение: все пути в структуре Крипке должны
быть <<справделивыми>>. <<Справедливым>> считается путь $\pi = s_0s_1\ldots$, такой, что
для бесконечно большого числа $i$ выполняется $s_i \in F$, где $F \in S$~--- некое
подмножество состояний. Иными словами, каждый путь в FCTL должен бесконечное число раз
проходить через состояния из определенного множества $F$.

Проверка формул как LTL, так и CTL (и, следовательно, CTL*) принадлежит к классу сложности
PSPACE и линейна по числу состояний~\cite{Sistla85complexity}. Однако, на практике
проверка CTL-формул менее затратна: сравнение в~\cite{DBLP:conf/spin/FaragoS09}
показывает, что на проверку LTL-формул уходит в два раза больше времени и объема памяти,
чем на проверку аналогичной по выразительной мощности CTL-формуле. Кроме того, проверка
CTL-формул имеет линейную сложность по длине формулы, а LTL-формул~--- экспоненциальную,
что делает использование CTL более привлекательным в практических задачах.

Как показано в \cite{Clarke97anotherlook}, большая часть LTL-формул может быть сведена к
CTL-формулам с условиями <<справедливости>>, что, в сочетании с меньшей затратностью
проверки, делает fairness CTL более распростаренным на практике, чем LTL.

%!!! [14][17]

\textit{$\mu$-исчисление}. $\mu$-исчисление~--- еще один формализм для задания условия
<<живости>>, описанный в~\cite{Clarke}. В нем используются те же кванторы пути, что и в
CTL*, и только один темпоральный оператор~--- $\mathbf{X}$ (neXt). Кроме того,
используются операторы наименьшей и наибольшей неподвижной точки:
$$ \mu Z~.~f(Z) = \cap \{Z~|~f(Z) \subseteq Z\}, $$
$$ \nu Z~.~f(Z) = \cup \{Z~|~f(Z) \supseteq Z\}, $$
где $f(Z)$~--- монотонная функция на некоторой решетке $P$.

В~\cite{Emerson97modelchecking} показано, что любой CTL*-формуле $f$ может быть поставлена
в соответствие формуле $g$ $\mu$-исчисления над решеткой $P(S)$ всех подмножеств множества
$S$. При этом начальное состояние $s_o$ вместе со всей моделью удовлетворяет $f$, если
$s_0 \in g$.

Любая LTL-формула может быть сведена к формуле $\mu$-исчисление с глубиной чередования
$\mu$ и $\nu$-операторов не больше двух, а для представления CTL-формул достаточно
единичной глубины, например:

$$\mathbf{AF~EG}~f = \mu Y~.~(\nu Z~.~f \cap \mathbf{EX}~Z) \cup \mathbf{AX}~Y.$$

Преимуществом $\mu$-исчисления является его универсальность и потенциально большая
выразительная мощность, чем у других формализмов~\cite{Emerson97modelchecking}.

\textbf{Алгоритмы проверки на модели}.

\textit{Глобальная и локальная проверка спецификации}. В зависимости от того,
конструируется ли при проверке на модели структура Крипке полностью, разлилчают
\emph{локальную} и \emph{глобальную} проверку. При глобальной проверке сначала целиком
строится структура Крипке, после чего на ней выполняется проверка спецификации. При
локальной проверке генерация новых состояний осуществляется совместно с проверкой
спецификации. Несоответствие спецификации в этом случае обычно обнаруживается, когда
построена только небольшая часть пространства состояний~\cite{Clarke}, что позволяет
сэкономить время и память для хранения состояний.

Для проверки условий <<надежности>>, представляющих из себя предикат $f(s)$, достаточно
проверить истинность предиката в каждом состоянии $M$. При локальной проверке истинность
$f(s)$ проверяется в новых состояниях по мере их генерации, и, если встречается состояние
$s'$, такое что $f(s') = \mathtt{false}$, проверка завершается с отрицательным результатом
и $s'$ в качестве \emph{контрпримера}.

Известно несколько алгоритмов для проверки условий <<живости>>, заданных в виде формул
темпоральной логики. В~\cite{Bhat95efficienton-the-fly} показано, что проверка CTL-формул
сводится к раскрашиванию (разметке) графа состояний $M$ в соответствии с изначельной $L$,
при которой каждая вершина посещается не более 2 раз.

Можно показать, что проверка LTL-формул (а также эквивалентных им CTL-формул с
ограничениями <<справедливости>>) эквивалентна проверке непустоты некоторого автомата
Бьюхи $\Omega$, сконструированного определелным образом по
$M$~\cite{Katoen}. В~\cite{Clarke97anotherlook} предлагается алгоритм проверки LTL-фомул,
аналогичный проверке CTL-формул с предварительным выделением в графе сильно связных
компонент.

В~\cite{Bollig_localparallel,Leucker_parallelmodel} предложен алгороитм для проверки
формул $\mu$-исчисления глубины не более двух. Задачу проверки формулы сводится к поиску
выигрышной стратегии на некотором игровом графе, который строится по структуре Крипке $M$
и проверяемой формуле. Данный алгоритм также требует выделения сильно связных компонент.

\textit{Символьная верификация}. \emph{Символьной верификацией} называется подход к
проверке на модели, при котором структура Крипке $M$ не строится вообще. Вместо этого
используется символьное представление отношения переходов $R(s, s')$ в виде OBDD, в
качестве аргументов которого выступают биты переменных $v_i$ состояния $s$ и $v_i'$
состояния $s'$~\cite{Clarke}.

Задача символьной верификации сводится к символьным преобразованиям булевой формулы $R(s,
s')$, представленной в виде OBDD. На практике, однако, преобразования могут получаться
громоздкими и данный подход оказывается не менее затратным, чем построение структуры
Крипке~\cite{Stern97parallelizingthe}.

%%%%%%%%%%%%%%%%%%%%%%% предполагаемые результаты и новизна %%%%%%%%%%%%%%%%%%%%%%%%%%%%

\textbf{Ожидаемые результаты}. Ожидаемым результатом работы является разработанный метод
эффективной параллельной проверки формул логики ветвящегося времени с условиями
справедливости на конечных моделях. Под эффективностью подразумевается уменьшение времени
простоя узлов за счет уменьшения числа удаленных вызовов между узлами.

\textbf{Научная новизна}. В отличие от логики линейного времени, на данный момент работы
по параллельной проверке формул логики ветвящегося времени отсутсвуют. Несмотря на то, что
формулы логики ветвящегося времени могут быть сведены к формулам $\mu$-исчисления, для
которых существуют определенные, хоть и неполные, разработки по параллельной проверке,
ожидается, что можно получить более эффективный (в терминах времени) способ проверки.

\bibliographystyle{../thesis/gost780u}
\bibliography{../thesis/thesis}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

%%% Идеи
%%% эффективное распределение состояний при проверке CTL-формул
%%% Символьная верификация, парал. OBDD -- опыт мерфи неудачен
%%% Генерация моделей по исходникому коду
%%% 
