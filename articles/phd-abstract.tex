\documentclass[a4paper,notitlepage,14pt]{article}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{textcomp}
\usepackage{indentfirst}
\usepackage{verbatim}

\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}

\usepackage{hyperref}

\usepackage{graphicx}

%\usepackage[left=20mm,right=20mm,top= 0mm,bottom=20mm]{geometry}

\usepackage{listings}
\lstset{
  basicstyle=\footnotesize,
  frame=none,
  breakatwhitespace=true,% разрыв строк только на whitespacce
  breaklines=true,       % переносить длинные строки
  captionpos=b,          % подписи снизу
  numbers=none,          % без нумерации
  showspaces=false,      % показывать пробелы подчеркиваниями -- идиотизм 70-х годов
  showstringspaces=false,
  showtabs=false,        % и табы тоже
  stepnumber=1,
  tabsize=4              % кому нужны табы по 8 символов?..
}

\sloppy
\hyphenpenalty=9000

\makeatletter
\renewcommand\@biblabel[1]{\hfill#1.}
\makeatother

\title{Параллельная верификацияф ормул логики ветвящегося времени на дискретных
  детерминированных моделях моделях} \author{Коротков\,И.\,А.}

\begin{document}

\maketitle

!!! вставить из главы 1 !!!

\emph{Проверка на модели} (model checking)~--- это автоматический метод верификации
параллельных систем с конечным числом состояний.~\cite{Clarke}.

При разработке сложных параллельных систем (систем, состоящих из нескольких асинхронно
работающих компонент) с высокой степенью надежности традиционных подходов к тестированию
зачастую бывает недостаточно, поскольку они позволяет выявить лишь часто воспроизводимые
ошибки. В программном обеспечении бортовых систем, работающих в реальном времени, в
сетевых протоколах и т.п. требуется исключить возможность ошибок полностью.

В ходе проверки на модели на основе дискретной детерминированной модели программы или
комплекса программ строится полное пространство состояний и на нем проверяется набор
интересующих нас утверждений~--- спецификация~\cite{Clarke}. Основной проблемой,
возникающей при этом, является <<комбинаторный взрыв>> числа состояний системы.

Примером использования проверки на модели является доказательство необходимости добавления
в протокол маршрутизации RIP расширения, называемого <<расщепленный горизонт>>. Проверка
модели сети из четырех маршрутизаторов, соединенных четыремя сетевыми интерфейсами, на
предмет возникновения циклов в маршрутных таблицах позволяет убедиться, что без
использования <<расщепленного горизонта>> существуют такие сценарии, при которых циклы
возникают.~\cite{RipOnSpin}

!!!одним из преимуществ проверки на модели является то, что она всегда завершается за
конечное время с ответом <<да>> или <<нет>>.

\section{Формализация проверки конечных моделей}
\label{sec:modelchecking}

Пространство состояний моделируемой программы или программного комплекса можно
формализовать, как модель Крипке (структуру Крипке, Kripke
structure)~\cite{Clarke}. Моделью Крипке $M$ над множеством атомарных высказываний $AP$
называют четверку $(S, S_0, R, L)$, где:

\begin{itemize}
\item $S$~--- конечное множество состояний;
\item $S_0 \in S$~--- множество начальных состояний;
\item $R \in S \times S$~--- отношение переходов, которые обязано быть тотальным, т.е. для
  каждого состояния $s \in S$ должно существовать такое состояние $s' \in S$, что имеет
  место $R(s, s')$;
\item $L\colon S \rightarrow 2^{AP}$~--- функция, которая помечает каждое состояние
  множеством атомарных высказываний, истинных в этом состоянии.
\end{itemize}

Путь в модели $M$ из состояния $s$~--- это бесконечная последовательность состояний $\pi =
s_0 s_1 \ldots$, такая, что $s_o = s$ и для всех $i \geq 0$ выполняется $R(s_i, s_{i+1})$.

Моделируемый программный комплекс в каждом своем состоянии описываются набором значений
переменных $V = \{v_0, v_1, \ldots\}$, принимающих значения на конечном множестве $D$
(домене интерпретации) и описывающих отдельные компоненты и взаимодействие между
ними. Множество $AP$ состоит из утверждений вида $v_i = d_i$, где $d_i \in D$. Таким
образом, каждое состояние $s$ в $M$ представляет собой отображение $V \rightarrow D$.

Отношение $R$ определяется следующим образом. Пусть имеются два состояния, $s_1$ и
$s_2$. Если в $s_1$ имеется компонент, который может выполнить атомарный переход
(изменение значений своих переменных), в результате выполнения которого система будет
находиться в состоянии $s_2$, тогда состояния $s_1$ и $s_2$ связаны отношением перехода:
$(s_1, s_2) \in R$. В случае, если нет такого состояния $s_2$, для которого бы выполнялось
$R(s_1, s_2)$, полагается $R(s_1, s_1)$, т.е. <<тупиковое>> состояние связано отношение
перехода само с собой.

\section{Формализация спецификации модели}
\label{sec:specification}

Существует несколько способов формализации спецификации верифицируемой модели:
темпоральные логики, к которым относятся: логика линейного времени LTL (linear time
logic), логика ветвящего времени CTL (computation tree logic), CTL* (объединение LTL и
CTL), логика переменного времени ATL (alternating time logic), логика расширенного времени
ETL (extended time logic); мю-исчисление; язык спецификации утверждений PSL.

Одной из наиболее выразительных и при этом удобной для понимания!!!ссылка!!! являеется
CTL*, объединяющая в себе логику линейного и ветвящегося времени.

Темпоральные логики позволяют описывать последовательности переходов между состояниями
системы. В перечисленных логиках, несмотря на название, время напрямую неиспользуется;
вместо этого используются утверждения, что некоторое состояние \emph{когда-либо будет}
достигнуто или что оно \emph{никогда не будет} достигнуто. Такие утверждения записываются
при помощи \emph{темпоральных операторов}, которые можно объединять булевыми
связками. Между собой темпоральные логики отличаются в основном набором доступных
операторов.

Формулы в CTL* составляются из атомарных утверждений, темпоральных операторов и
\emph{кванторов пути}. В CTL* имеется два квантора:

\begin{itemize}
\item $\mathbf{A}$ (all)~--- <<для всех путей, выходящих из данного состояния>>,
\item $\mathbf{E}$ (exists)~--- <<существует такой путь, выходящий из данного состояния>>
\end{itemize}

\noindent и 5 операторов:

\begin{itemize}
\item $\mathbf{F}$ (finally)~--- <<рано или поздно в пути встретится состояние, в котором
  выполняется указанное утверждение>>,
\item $\mathbf{G}$ (globally)~--- <<во всех состояниях пути выполняется указанное
  утверждение>>,
\item $\mathbf{X}$ (next)~--- <<в следующем состояния пути выполняется указанное
  утверждение>>,
\item $\mathbf{U}$ (until)~--- <<пока в пути не появится состояние, в котором выполняется
  второе утверждение, во всех состояниях должно выполняться первое утверждение>>.
\end{itemize}

Например, формула $\mathbf{AFG}~ x$ означает <<во всех путях, идущих из начального
состояния, с некоторого состояния на протяжении всего пути выполняется $x$>>, а формула
$\mathbf{AGEF}~ x$ означает <<во всех путях, идущих из начального состояния, из каждого
состояния есть хотя бы один путь, в котором рано или поздно встретится состояние, в
котором выполняется $x$>>.

В CTL* выделяют два собственных пересекающихся подможества: логику линейного времени LTL и
логику ветвящегося времени CTL, объединение которых составляет саму CTL*. Различие между
ними заключается в допустимых комбинациях кванторов пути и темпоральных операторов. 

Логика линейного времени LTL состоит из формул вида $\mathbf{A}~f$, где $f$ не содержит
кванторов пути, только атомарные утверждения и темпоральные операторы. Примерами
LTL-формул являются $\mathbf{F}~x~\mathbf{U}~y$, $\mathbf{G}~x \Rightarrow \mathbf{F}~y$
($\mathbf{A}$ в начале обычно опускается).

Логика ветвящегося времени CTL состоит из формул, где кванторы пути чередуются с
темпоральными операторами (т.е. перед каждым темпоральным оператором должен стоять квантор
пути). Примерами CTL-формул являются $\mathbf{AG}~\mathbf{EF}~x$, $\mathbf{AG} x
\Rightarrow \mathbf{EF} y$.

Можно сказать, что LTL-формулы представляют собой утверждения относительно событий,
происходящих на каждом возможном пути в модели $M$, отсюда название <<логика
\emph{линейного} времени>>. В то же время, CTL-формулы представляют собой утверждения о
наличии выбора пути в определенных состояниях, приводящего к желаемому результату.

!!! fair CTL

\section{Применение проверки на модели}
\label{sec:applications}

!!!!

Условно можно разделить ошибки в программных комплексах на четыре категории по двум признакам, как
это показано в табл.~\ref{tab:error-classes}. Ошибки с высокой частотой возникнования
могут быть выявлены тестированием. Для ошибок высокой критичности, возникающих с малой
вероятностью, нужные иные способы поиска.

В случае, если проверяется не параллельный программный комплекс, а некий параллельный
алгоритм или протокол взаимодействия~--- например, новое расширение TCP для контроля
трафика~--- тестирование также неприменимо, поскольку тестировать нечего. В обоих случаях
необходимо использовать метод, называемый \Term{проверкой модели}.

\begin{table}[hb]
  \centering
  \caption{Классы ошибок и способы их устранения}
  \begin{tabular}{|c|c|c|} \hline
    \textbf{Вероятность} & \multicolumn{2}{|c|}{\bf Степень критичности} \\ \cline{2-3}
    \textbf{возникновения} & Высокая & Низкая \\ \hline
    Высокая & Тестирование & Тестирование \\  \hline
    Низкая  & \textbf{Проверка модели} &  \\  \hline
  \end{tabular}  
  \label{tab:error-classes}
\end{table}

!!!!

\section{Используемые на практике средства верификации}
\label{sec:existing-tools}

Существует большое количество программных средств для проверки свойств моделей, наиболее
универсальным и распространенным из которых является ПО \Code{Spin}~\cite{SpinRoot}. Он и
будет использоваться в качестве основы для дальнейшей работы. Для описания моделей в ПО
Spin используется язык описания \Code{Promela} (PROtocol Meta Language).

!!! описать, что на практике !!!

!!! Intel, использование CTL

\section{Проблема роста числа состояний}
\label{sec:state-explosion}

Последовательное построение пространства состояний $S$ с ростом размера модели быстро
становится невозможным из-за нехватки ОЗУ для хранения множества достигнутых состояний. В
табл.~\ref{tab:models-statecount} приведены данные для двух моделей: модели задачи об
обедающих философов и приведенной выше в качестве примера модели RIP-протокола на четырех
сетевых маршрутизаторах.

\begin{table}
  \centering
  \begin{tabular}{|r|l|l|}
    \hline
    Модель                  & Состояний         & Переходов       \\
    \hline
    Философы (5)            & $2.8 \cdot 10^4$  & $4.2 \cdot 10^4$ \\
    Философы (7)            & $3.6 \cdot 10^5$  & $6.0 \cdot 10^5$ \\
    RIP (4 маршрутизатора)  & $1.6 \cdot 10^8$  & $4.8 \cdot 10^9$ \\
    \hline
  \end{tabular}
  \caption{Количество состояний и переходов в различных моделях}
\label{tab:models-statecount}
\end{table}

Из табл. \ref{tab:models-statecount} видно, что для реальных моделей традиционный подход к
генерации пространства состояний поиском в глубину или ширину становится проблематичен: к
примеру, модель RIP-протокола с 5-ю маршрутизаторами потребует уже более 100 Гб
оперативной памяти для хранения пространства состояний.

Существует ряд подходов, решающих данную проблему. Среди них можно выделить:

\begin{itemize}
\item хранение состояний во внешней памяти~--- данный подход практически никогда не
  применяется, так как время верификации возрастает на несколько порядков~\cite{Clarke};
\item методы оптимизации, уменьшающие количество генерируемых и хранимых состояний:
  сокращение частных порядков~\cite{POD};
\item методы оптимизации, уменьшающие расход памяти на хранение пространства состояний:
  сжатие битового представления состояния кодами хаффмана~\cite{StateCompr}, рекурсивное
  кодирование состояний~\cite{StateCompr}, битовое хэширование без проверки
  коллизий~\cite{BitHash1,Wolper}.
\end{itemize}

Недостаток вышеперечисленных методов в том, что они дают ограниченный, плохо
масштабируемый прирост числа состояний, которые возможно хранить, в обмен на уменьшение
скорости (сжатие состояний) или <<потерю>> части состояний (битовое хэширование без
проверки коллизий).

Альтернативным решением проблемы роста состояний является использование средств
параллельных вычислений для распределения хранимых состояний между несколькими узлами
вычислительной сети.

\section{Существующие работы по данному направлению}
\label{sec:other-work}

Первые работы по параллелизации генерации состояний~\cite{LS99} появились еще в 90-х~гг.,
однако не получили тогда практического применения. Позже, с 2000~г., в университете Брно
был опубликован ряд работ~\cite{DLTL1,DLTL2} по паралельной генерации состояний для
проверки условий <<живости>>, заданных в виде LTL-формул. На основе этих работ в
2005~г. авторами был разработан программный продукт \texttt{DiVinE}~\cite{DiVinE}.
l

!!! проблемы верификации временной логики

!!! cуществующие средства

!!! существулющие работы по LTL

!!! отсутствие работ по CTL

\section{Проделанная работа}
\label{sec:my-work}

\bibliographystyle{../thesis/gost780u}
\bibliography{../thesis/thesis}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
