\documentclass[a4paper,notitlepage,14pt]{article}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{textcomp}
\usepackage{indentfirst}
\usepackage{verbatim}

\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}

\usepackage{hyperref}

\usepackage{graphicx}

%\usepackage[left=20mm,right=20mm,top= 0mm,bottom=20mm]{geometry}

\usepackage{listings}
\lstset{
  basicstyle=\footnotesize,
  frame=none,
  breakatwhitespace=true,% разрыв строк только на whitespacce
  breaklines=true,       % переносить длинные строки
  captionpos=b,          % подписи снизу
  numbers=none,          % без нумерации
  showspaces=false,      % показывать пробелы подчеркиваниями -- идиотизм 70-х годов
  showstringspaces=false,
  showtabs=false,        % и табы тоже
  stepnumber=1,
  tabsize=4              % кому нужны табы по 8 символов?..
}

\sloppy
\hyphenpenalty=9000

\makeatletter
\renewcommand\@biblabel[1]{\hfill#1.}
\makeatother

\title{Параллельная верификация формул логики ветвящегося времени на дискретных
  детерминированных моделях моделях} \author{Коротков\,И.\,А.}

\begin{document}

\maketitle

\emph{Проверка на модели} (model checking)~--- это автоматический метод верификации
параллельных систем с конечным числом состояний~\cite{Clarke}.

При разработке сложных параллельных систем (систем, состоящих из нескольких асинхронно
функционирующих компонент) с высокой степенью надежности традиционных подходов к
тестированию зачастую бывает недостаточно~\cite{Clarke}, поскольку они позволяет выявить
лишь часто воспроизводимые ошибки. Проверка на модели применяется в случаях, когда
требуется полностью исключить определенные классы ошибок~--- например, в программном
обеспечении бортовых систем~\cite{Havelund98formalanalysis,CamaraArincModel}, сетевых
протоколов~\cite{RipOnSpin}, электронных схем микрочипов~\cite{Glazberg_psl:beyond} и т.п.

В ходе проверки на модели на основе дискретной детерминированной модели программы или
комплекса программ строится полное пространство состояний и на нем проверяется набор
интересующих нас утверждений~--- спецификация~\cite{Velder}. Основной проблемой,
возникающей при этом, является <<комбинаторный взрыв>> числа состояний
системы\cite{Clarke}.

Примером использования проверки на модели является доказательство необходимости добавления
в протокол маршрутизации RIP расширения, называемого <<расщепленный
горизонт>>~\cite{Black00:IP}. Проверка модели сети из четырех маршрутизаторов, соединенных
четыремя сетевыми интерфейсами, на предмет возникновения циклов в маршрутных таблицах
позволяет убедиться, что без использования <<расщепленного горизонта>> существуют такие
сценарии, при которых циклы возникают~\cite{RipOnSpin}.

% !!!одним из преимуществ проверки на модели является то, что она всегда завершается за
% конечное время с ответом <<да>> или <<нет>>.

\section{Формализация конечной модели}
\label{sec:modelchecking}

\subsection{Структуры Крипке}
\label{sec:kripke}

Пространство состояний моделируемой программы или программного комплекса можно
формализовать, как модель Крипке (структуру Крипке, Kripke
structure)~\cite{Clarke}. Моделью Крипке $M$ над множеством атомарных высказываний $AP$
называют четверку $(S, S_0, R, L)$, где:

\begin{itemize}
\item $S$~--- конечное множество состояний;
\item $S_0 \in S$~--- множество начальных состояний;
\item $R \in S \times S$~--- отношение переходов, которые обязано быть тотальным, т.е. для
  каждого состояния $s \in S$ должно существовать такое состояние $s' \in S$, что имеет
  место $R(s, s')$;
\item $L\colon S \rightarrow 2^{AP}$~--- функция, которая помечает каждое состояние
  множеством атомарных высказываний, истинных в этом состоянии.
\end{itemize}

Путь в модели $M$ из состояния $s$~--- это бесконечная последовательность состояний $\pi =
s_0 s_1 \ldots$, такая, что $s_o = s$ и для всех $i \geq 0$ выполняется $R(s_i, s_{i+1})$.

Моделируемый программный комплекс в каждом своем состоянии описываются набором значений
переменных $V = \{v_0, v_1, \ldots\}$, принимающих значения на конечном множестве $D$
(домене интерпретации) и описывающих отдельные компоненты и взаимодействие между
ними. Множество $AP$ состоит из утверждений вида $v_i = d_i$, где $d_i \in D$. Таким
образом, каждое состояние $s$ в $M$ представляет собой отображение $V \rightarrow D$.

Отношение $R$ определяется следующим образом. Пусть имеются два состояния, $s_1$ и
$s_2$. Если в $s_1$ имеется компонент, который может выполнить атомарный переход
(изменение значений своих переменных), в результате выполнения которого система будет
находиться в состоянии $s_2$, тогда состояния $s_1$ и $s_2$ связаны отношением перехода:
$(s_1, s_2) \in R$. В случае, если нет такого состояния $s_2$, для которого бы выполнялось
$R(s_1, s_2)$, полагается $R(s_1, s_1)$, т.е. <<тупиковое>> состояние связано отношение
перехода само с собой.

\subsection{Двоичные диаграммы принятия решений}
\label{sec:obdd}

Альтернативным способом представления модели являются упорядоченные двоичные диаграммы
принятия решений (\emph{ordered binary decision diagram}, OBDD)!!!. 

!!! определение !!!

Модель описывается при помощи OBDD следующим образом 

!!! описание R(...) <=> f(...) = 1 !!!

\section{Формализация спецификации модели}
\label{sec:specification}

\subsection{Виды условий спецификации}
\label{sec:cond-types}

Срецификация, соответствие которой проверяется для данной модели, может включать в себя
условия двух видов: условия <<безопасности>> (safety conditions) и условия <<живости>>
(livenes conditions).

Условия <<надежности>> (\emph{safety conditions})~--- утверждения, что <<не случится
ничего плохого>>. Примером может служить утверждение <<процессы не входят в состояние
взаимоблокировки>>. Все такие условия могут быть сведены!!! к утверждению, что ни в одном
из путей $\pi$ модели $M$ ни одно состояние не удовлетворяет некоторому предикату $f(s)$
относительно значений переменных в данном состоянии: $f(s) = f(v_i\|_s)$.

Условия <<живости>> (\emph{liveness conditions})~--- утверждения, что <<случится что-то
хорошее>>. Например, <<за каждым запросом будет рано или поздно следовать ответ>>. Данный
класс утверждений формализовать значительно сложнее. Многие условия <<живости>> могут
быть!!! сведены к следующему утверждению: каждый путь $\pi$ в модифицированный модели $M'$
содержит бесконечно много состояний, для которых выполняется определенный предикат $f(s)$.

Существует несколько способов формализации условии <<живости>>: темпоральные (временные)
логики~\cite{Clarke,Pandya01modelchecking},
\mu-исчисление~\cite{Leucker_parallelmodel,Emerson97modelchecking}, язык спецификации
утверждений PSL~\cite{Glazberg_psl:beyond}.

Одним из наиболее выразительных и при этом удобным для понимания~\cite{Stirling96modaland}
способом являются темпоральные логики (temporal logics).

\subsection{Темпоральные логики}
\label{sec:temporal-logics}

Темпоральные логики позволяют описывать последовательности переходов между состояниями
системы. В перечисленных логиках, несмотря на название, время напрямую неиспользуется;
вместо этого используются утверждения, что некоторое состояние \emph{когда-либо будет}
достигнуто или что оно \emph{никогда не будет} достигнуто. Такие утверждения записываются
при помощи \emph{темпоральных операторов}, которые можно объединять булевыми
связками. Между собой темпоральные логики отличаются в основном набором доступных
операторов. Далее рассматривается наиболее часто используемая временная логика~---
CTL*~\cite{Stirling96modaland}.

В CTL* формулы составляются из атомарных утверждений, темпоральных операторов и
двух \emph{кванторов пути}:

\begin{itemize}
\item $\mathbf{A}$ (all)~--- <<для всех путей, выходящих из данного состояния>>,
\item $\mathbf{E}$ (exists)~--- <<существует такой путь, выходящий из данного состояния>>.
\end{itemize}

Темпоральных операторов в CTL* имеется пять:

\begin{itemize}
\item $\mathbf{F} f$ (finally)~--- <<рано или поздно в пути встретится состояние, в котором
  выполняется указанное утверждение>>,
\item $\mathbf{G} f$ (globally)~--- <<во всех состояниях пути выполняется указанное
  утверждение>>,
\item $\mathbf{X} f$ (next)~--- <<в следующем состояния пути выполняется указанное
  утверждение>>,
\item $f \mathbf{U} g$ (until)~--- <<пока в пути не появится состояние, в котором выполняется
  второе утверждение, во всех состояниях должно выполняться первое утверждение>>,
\item $f \mathbf{R} g$ (release)~--- !!!.
\end{itemize}

Например, формула $\mathbf{AFG}~ f$ означает <<во всех путях, идущих из начального
состояния, с некоторого состояния на протяжении всего пути выполняется $f$>>, а формула
$\mathbf{AGEF}~ f$ означает <<во всех путях, идущих из начального состояния, из каждого
состояния есть хотя бы один путь, в котором рано или поздно встретится состояние, в
котором выполняется $f$>>.

В CTL* выделяют два собственных пересекающихся подможества: логику линейного времени
(linear time logic, LTL) и логику ветвящегося времени (computational tree logic, CTL),
объединение которых составляет само множество CTL*. Различие между ними заключается в
допустимых комбинациях кванторов пути и темпоральных операторов.

Логика линейного времени LTL состоит из формул вида $\mathbf{A}~f$, где $f$ не содержит
кванторов пути, только атомарные утверждения и темпоральные операторы. Примерами
LTL-формул являются $\mathbf{F}~x~\mathbf{U}~y$, $\mathbf{G}~x \Rightarrow \mathbf{F}~y$
($\mathbf{A}$ в начале обычно опускается).

Логика ветвящегося времени CTL состоит из формул, где кванторы пути чередуются с
темпоральными операторами (т.е. перед каждым темпоральным оператором должен стоять квантор
пути). Примерами CTL-формул являются $\mathbf{AG}~\mathbf{EF}~x$, $\mathbf{AG} x
\Rightarrow \mathbf{EF} y$.

Можно сказать, что LTL-формулы представляют собой утверждения относительно событий,
происходящих на каждом возможном пути в модели $M$, отсюда название <<логика
\emph{линейного} времени>>. В то же время, CTL-формулы представляют собой утверждения о
наличии выбора пути в определенных состояниях, приводящего к желаемому результату, отсюда
название <<логика \emph{ветвящегося} времени>>~\cite{Clarke}.

На практике CTL используется чаще, чем LTL!!!. Однако, у CTL имеется существенный
недостаток: невозможность выразить так называемые условия <<сильной
справедливости>>~\cite{Katoen,DBLP:conf/spin/FaragoS09}. Условия <<слабой справедливости>>
имеющие вид $\mathbf{AGF}~P$ (<<на каждом пути бесконечно часто встречается состояние, в
котором выполняется $p$>>) выразимы эквивалентной CTL-формулой $\mathbf{AF~AG}~p$. В то же
время условия <<сильной справедливости>>, имеющие виде $\mathbf{AG} (p \Rightarrow
\mathbf{F} q)$ (<<на каждом возможном пути после состояния, в котором выполняется условие
$p$, рано или поздно встретится состояние, в котором выполняется условие $q$>>), не имеет
эквивалентной CTL-формулы.

Это делает невозможным проверку утверждений типа <<за запросом всегда рано или поздно
следует ответ>>. Данный недостаток CTL решается его модификацией~--- fairness CTL (логика
ветвящего времени с условиями <<справедливости>>). Формулы FCTL представляют из себя
обычные CTL-формулы, однако добавляется ограничение: все пути в структуре Крипке должны
быть <<справделивыми>>. <<Справедливым>> считается путь $\pi = s_0s_1\ldots$, такой, что
для бесконечно большого числа $i$ выполняется $s_i \in F$, где $F \in S$~--- некое
подмножество состояний. Иными словами, каждый путь в FCTL должен бесконечное число раз
проходить через состояния из определенного множества $F$.

Проверка формул как LTL, так и CTL (и, следовательно, CTL*) принадлежит к классу сложности
PSPACE!!! и линейна по число состояний!!!. Однако, на практике проверка CTL-формул менее
затратна: сравнение в !!! показывает, что на проверку LTL-формул уходит в два раза больше
времени и объема памяти, чем на проверку аналогичной по выразительной мощности
CTL-формуле. Кроме того, проверка CTL-формул имеет линейную сложность по длине формулы, а
LTL-формул~--- экспоненциальную, что делает использование CTL более привлекательным в
практических задачах.

Как показано в !!!, большая часть LTL-формул может быть сведена к CTL-формулам с условиями
<<справедливости>>, что, в сочетании с меньшей затратностью проверки, делает fairness CTL
более распростаренным на практике, чем LTL.

!!! [14][17]

\subsection{\mu-исчисление}
\label{sec:mu-calculus}

!!! можно сюда пихнуть про мю-исисчление

\section{Алгоритмы проверки на модели}
\label{sec:modelchk-methods}

\subsection{Глобальная и локальная проверка спецификации}
\label{sec:global}

В зависимости от того, конструируется ли при проверке на модели структура Крипке
полностью, разлилчают \emph{локальную} и \emph{глобальную} проверку. При глобальной
проверке сначала целиком строится структура Крипке, после чего на ней выполняется проверка
спецификации. При локальной проверке генерация новых состояний осуществляется совместно с
проверкой спецификации. Несоответствие спецификации в этом случае обычно обнаруживается,
когда построена только небольшая часть пространства состояний!!!, что позволяет сэкономить
время и память для хранения состояний.

Для проверки условий <<надежности>>, представляющих из себя предикат $f(s)$, достаточно
проверить истинность предиката в каждом состоянии $M$. При локальной проверке истинность
$f(s)$ проверяется в новых состояниях по мере их генерации, и, если встречается состояние
$s'$, такое что $f(s') = \mathtt{false}$, проверка завершается с отрицательным результатом
и $s'$ в качестве \emph{контрпримера}.

Известно несколько алгоритмов для проверки условий <<живости>>, заданных в виде формул
темпоральной логики. В !!! показано, что проверка CTL-формул сводится к раскрашиванию
(разметке) графа состояний $M$ в соответствии с изначельной $L$, при которой каждая
вершина посещается не более 2 раз. 

Можно показать, что проверка LTL-формул (а также эквивалентных им CTL-формул с
ограничениями <<справедливости>>) эквивалентна проверке непустоты некоторого автомата
Бьюхи $\Omega$, сконструированного определелным образом по $M$!!!. В !!! предлагается
алгоритм проверки LTL-фомул, аналогичный проверке CTL-формул с предварительным выделением
в графе сильно связных компонент.

В !!! и !!! предложен алгороитм для проверки формул \mu-исчисления глубины не более двух,
к которым могут быть сведены все формулы CTL*!!!. Задачу проверки формулы сводится к
поиску выигрышной стратегии на некотором игровом графе, который строится по структуре
Крипке $M$ и проверяемой формуле. Данный алгоритм также требует выделения сильно связных
компонент.

\subsection{Символьная верификация}
\label{sec:symbolic}

\emph{Символьной верификацией} называется подход к проверке на модели, при котором
структура Крипке $M$ не строится вообще. Вместо этого используется символьное
представление отношения переходов $R(s, s')$ в виде OBDD, в качестве аргуументов которого
выступают биты переменных $v_i$ состояния $s$ и $v_i'$ состояния $s'$.

Задача символьной верификации сводится к символьным преобразованиям булевой формулы $R(s,
s')$, представленной в виде OBDD!!!. На практике, однако, преобразования могут получаться
громоздкими и данный подход оказывается не менее затратным, чем построение структуры
Крипке!!!.

\section{Существующие средства проверки на модели}
\label{sec:existing-tools}

Существует большое количество программных средств для проверки на модели. 

ПО \textbf{Spin}~\cite{SpinRoot}, разработнное Дж. Хольцманом в Bell Labs в 1980,
использут для описания модели язык \textbf{Promela} (PROtocol Meta Language). Модель в
языке Promela представляется в виде набора взаимодействующих чрез каналы и глобальные
переменные конечных автоматов~--- процессов. Модель Крипке представляет собой пространство
состояний КА, получающегося в результате пересечения КА всех процессов, входящих в
модель. ПО \textbf{Spin} поддерживает проверку условий <<надежности>> в виде утверждений
(\emph{assert}) и условий <<живости>>, заданных формулами LTL.

При проверке на модели \textbf{SPIN} совмещает генерацию состояний с проверкой утверждений. Для
проверки LTL-формул вместо исходной структуры $M$ строится автомат Бьюхи $\Omega$ и, при
обнаружении допускающего цикла, проверка завершается с отрицательным результатом. Для
генерации состояний используется обход графа в глубину с вложенным обходом в глубину для
поиска циклов!!!.

Другим широко распространенным средством проверки на модели является
\textbf{NuSMV}~\cite{Cimatti00nusmv:a}!!!, использующий в качестве языка описания SMV
(Symbolic Model Verification). \textbf{NuSMV} использует внутренне представление модели в
виде OBDD и символьную верификацию. В качестве языка спецификаций поддерживается fairness
CTL.

ПО \textbf{Mur\phi}~\cite{Dill96murphi}, созданное для проверки алгоритмов кэширования в
мультипроцессорных системах!!!, во многом аналогично ПО \textbf{Spin}: используется
локальная проверка на модели, генерация состояний осуществляется путем обхода графа в
глубину. Однако, в \textbf{Mur\phi} поддерживаются лишь условия <<надежности>>.

!!! UCLID

\section{Проблема роста числа состояний}
\label{sec:state-explosion}

Главной проблемой проверки на модели является небходимость в процессе обхода графа
состояний хранить множество посещенных состояний. С ростом размера множество состояний $S$
проверка быстро становится невозможной из-за нехватки ОЗУ для хранения множества
посещенных состояний. В табл.~\ref{tab:models-statecount} приведены данные для двух
моделей: модели задачи об обедающих философов и приведенной выше в качестве примера модели
RIP-протокола на четырех сетевых маршрутизаторах!!!~--- при их проверке на ПО
\textbf{Spin}.

\begin{table}
  \centering
  \begin{tabular}{|r|l|l|}
    \hline
    Модель                  & Состояний         & Переходов       \\
    \hline
    Философы (5)            & $2.8 \cdot 10^4$  & $4.2 \cdot 10^4$ \\
    Философы (7)            & $3.6 \cdot 10^5$  & $6.0 \cdot 10^5$ \\
    RIP (4 маршрутизатора)  & $1.6 \cdot 10^8$  & $4.8 \cdot 10^9$ \\
    \hline
  \end{tabular}
  \caption{Количество состояний и переходов в различных моделях}
\label{tab:models-statecount}
\end{table}

Из табл.~\ref{tab:models-statecount} видно, что для реальных моделей традиционный подход к
генерации пространства состояний поиском в глубину или ширину становится проблематичен: к
примеру, модель RIP-протокола с 5-ю маршрутизаторами потребует уже более 100 Гб
оперативной памяти для хранения пространства состояний.

Существует ряд подходов, решающих данную проблему. Среди них можно выделить:

\begin{itemize}
\item хранение состояний во внешней памяти~--- данный подход практически никогда не
  применяется, так как время верификации возрастает на несколько порядков~\cite{Clarke};
\item символьная верификация~--- как уже было сказано ранее, на хранение OBDD
  преобразованных формул зачастую уходит не меньше места, чем на хранение посещенных
  состояний;
\item методы оптимизации, уменьшающие количество генерируемых и хранимых состояний:
  сокращение частных порядков~\cite{POD};
\item методы оптимизации, уменьшающие расход памяти на хранение пространства состояний:
  сжатие битового представления состояния кодами хаффмана~\cite{StateCompr}, рекурсивное
  кодирование состояний~\cite{StateCompr}, битовое хэширование без проверки
  коллизий~\cite{BitHash1,Wolper}.
\end{itemize}

Недостаток вышеперечисленных методов в том, что они дают ограниченный, плохо
масштабируемый прирост числа состояний, которые возможно хранить, в обмен на уменьшение
скорости (сжатие состояний) или <<потерю>> части состояний (битовое хэширование без
проверки коллизий).

Альтернативным решением проблемы роста состояний является использование средств
параллельных вычислений для распределения хранимых состояний между несколькими узлами
вычислительной сети.

\section{Существующие работы по данному направлению}
\label{sec:other-work}

Первые работы по параллелизации генерации состояний!!! появились еще в 87~г. Они
имели ряд недостатков: !!!

В !!! предлагается параллельная версия верификатора \textbf{Mur\phi}, использующая
параллельный обход графа сосотяний в ширину с равномерным распределением состояний между
узлами. Одним из принципиальных недостатков этого подхода быао большое количество
пересылаемых между узлами сообщений, содержащих новые состояния. Авторы предлагали в
качестве решения проблемы буферизацию сообщений при отправке.

В ~\cite{LS99} предлагается иной подход: распределение сосотяний, обладающее одновременно
свойствами равномерности и локальности, что позволило уменьшить число передаваемых
сообщений.
!!! расширить

В !!! предлагается также идея параллельного хранения и обработки OBDD, кроме того, попытки
параллельного хранения OBDD предпринимались в ходе разработке параллельной версии
\textbf{Mur\phi}!!!, однако, оказались неуспешны.

Перечисленные работы решали лишь задачу параллельной генерации и хранения пространства
состояний. При этом возможна проверка условий <<безопасности>>, т.е. проверка истичнности
некоторого утверждения $f(s)$ во всех состояниях. Однако, проверка условий <<живости>>,
при этом не рассматривалась.

Главная сложность проверки CTL*-формул (условий <<живости>>) на модели заключается в
необходимости поиска сильно связных компонент в графе состояний, требующем \emph{поиска
  циклов}. Обнаружение циклов легко осуществимо при поиске в глубину (алгоритм <<nested
DFS>>!!!), но при параллельной генерации сосотяний какой-либо глобальный порядок обхода
состояний отсутсвует и поиск циклов затруднен.

В университете Брно опубликован ряд работ~\cite{DLTL1,DLTL2}, в которых рассматривается
параллельная проверка условий <<живости>>, заданных в виде LTL-формул. На основе этих
работ в 2005~г. авторами был разработан программный продукт \texttt{DiVinE}~\cite{DiVinE}.

Авторами \texttt{DiVinE} используется несколько подходов. Один из них заключается в выборе
функции распределения состояний, которая приводит к локализации всех циклов в пределах
одного узла~\cite{DLTL1}, в результате чего поиск циклов проводится лишь локально. Другой
алгоритм представляет собой параллельное обнаружение циклов с последующей (дорогостояющей)
последовательной проверкой~\cite{DLTL2}.

В !!! предложена параллельная версия алгоритма проверки формул \mu-исчисления глубины не
более двух, к которым могут быть сведены формулы CTL*. Однако, предложенный подход
неполон и требует доработки. В частности, не рассматривается способ эффективного
параллельного разбиения графа на компоненты связности.

Таким образом, работы, имеющие практический результат, по параллельной проверке CTL-формул
на модели на данный момент отсутствуют. При том, что CTL является более распространенной и
вычислительно эффективной, чем LTL, данная задача является актуальной для современной
области формальной верификации.

\section{Проделанная работа}
\label{sec:my-work}

В!!!ссылка на себя!!! предложен способ распределений состояний при параллельной генерации,
позволяющий сократить в несколько раз число удаленных вызовов при генерации.

!!! как делается проверка: раскраска графа
!!! распределение состояний с целью уменьшить число пересылаемых сообщений

План в итоге:
+ Что такое MC
+ формализация: модель крипке
+ формализация: CTL, LTL, mu
+ применение МС на практике, существующие средства
+ проблема роста числа состояний
+ существующие работы по решению проблем
- проделанная мной работа
- план на дисер
- цель и задачи

\bibliographystyle{../thesis/gost780u}
\bibliography{../thesis/thesis}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 

%%% Идеи
%%% эффективное распределение состояний при проверке CTL-формул
%%% Символьная верификация, парал. OBDD -- опыт мерфи неудачен
%%% Генерация моделей по исходникому коду
%%% 