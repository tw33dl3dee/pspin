\documentclass[a4paper,notitlepage,14pt]{article}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{textcomp}
\usepackage{indentfirst}
\usepackage{verbatim}

\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}

\usepackage{hyperref}

\usepackage{graphicx}

%\usepackage[left=20mm,right=20mm,top= 0mm,bottom=20mm]{geometry}

\usepackage{listings}
\lstset{
  basicstyle=\footnotesize,
  frame=none,
  breakatwhitespace=true,% разрыв строк только на whitespacce
  breaklines=true,       % переносить длинные строки
  captionpos=b,          % подписи снизу
  numbers=none,          % без нумерации
  showspaces=false,      % показывать пробелы подчеркиваниями -- идиотизм 70-х годов
  showstringspaces=false,
  showtabs=false,        % и табы тоже
  stepnumber=1,
  tabsize=4              % кому нужны табы по 8 символов?..
}

\sloppy
\hyphenpenalty=9000

\makeatletter
\renewcommand\@biblabel[1]{\hfill#1.}
\makeatother

\title{Параллельная верификацияф ормул логики ветвящегося времени на дискретных
  детерминированных моделях моделях} \author{Коротков\,И.\,А.}

\begin{document}

\maketitle

!!! вставить из главы 1 !!!

\emph{Проверка на модели} (model checking)~--- это автоматический метод верификации
параллельных систем с конечным числом состояний.~\cite{Clarke}.

При разработке сложных параллельных систем (систем, состоящих из нескольких асинхронно
работающих компонент) с высокой степенью надежности традиционных подходов к тестированию
зачастую бывает недостаточно, поскольку они позволяет выявить лишь часто воспроизводимые
ошибки. В программном обеспечении бортовых систем, работающих в реальном времени, в
сетевых протоколах и т.п. требуется исключить возможность ошибок полностью.

В ходе проверки на модели на основе дискретной детерминированной модели программы или
комплекса программ строится полное пространство состояний и на нем проверяется набор
интересующих нас утверждений~--- спецификация~\cite{Clarke}. Основной проблемой,
возникающей при этом, является <<комбинаторный взрыв>> числа состояний системы.

Примером использования проверки на модели является доказательство необходимости добавления
в протокол маршрутизации RIP расширения, называемого <<расщепленный горизонт>>. Проверка
модели сети из четырех маршрутизаторов, соединенных четыремя сетевыми интерфейсами, на
предмет возникновения циклов в маршрутных таблицах позволяет убедиться, что без
использования <<расщепленного горизонта>> существуют такие сценарии, при которых циклы
возникают.~\cite{RipOnSpin}

!!!одним из преимуществ проверки на модели является то, что она всегда завершается за
конечное время с ответом <<да>> или <<нет>>.

\section{Формализация проверки конечных моделей}
\label{sec:modelchecking}

Пространство состояний моделируемой программы или программного комплекса можно
формализовать, как модель Крипке (структуру Крипке, Kripke
structure)~\cite{Clarke}. Моделью Крипке $M$ над множеством атомарных высказываний $AP$
называют четверку $(S, S_0, R, L)$, где:

\begin{itemize}
\item $S$~--- конечное множество состояний;
\item $S_0 \in S$~--- множество начальных состояний;
\item $R \in S \times S$~--- отношение переходов, которые обязано быть тотальным, т.е. для
  каждого состояния $s \in S$ должно существовать такое состояние $s' \in S$, что имеет
  место $R(s, s')$;
\item $L\colon S \rightarrow 2^{AP}$~--- функция, которая помечает каждое состояние
  множеством атомарных высказываний, истинных в этом состоянии.
\end{itemize}

Путь в модели $M$ из состояния $s$~--- это бесконечная последовательность состояний $\pi =
s_0 s_1 \ldots$, такая, что $s_o = s$ и для всех $i \geq 0$ выполняется $R(s_i, s_{i+1})$.

Моделируемый программный комплекс в каждом своем состоянии описываются набором значений
переменных $V = \{v_0, v_1, \ldots\}$, принимающих значения на конечном множестве $D$
(домене интерпретации) и описывающих отдельные компоненты и взаимодействие между
ними. Множество $AP$ состоит из утверждений вида $v_i = d_i$, где $d_i \in D$. Таким
образом, каждое состояние $s$ в $M$ представляет собой отображение $V \rightarrow D$.

Отношение $R$ определяется следующим образом. Пусть имеются два состояния, $s_1$ и
$s_2$. Если в $s_1$ имеется компонент, который может выполнить атомарный переход
(изменение значений своих переменных), в результате выполнения которого система будет
находиться в состоянии $s_2$, тогда состояния $s_1$ и $s_2$ связаны отношением перехода:
$(s_1, s_2) \in R$. В случае, если нет такого состояния $s_2$, для которого бы выполнялось
$R(s_1, s_2)$, полагается $R(s_1, s_1)$, т.е. <<тупиковое>> состояние связано отношение
перехода само с собой.

\section{Формализация спецификации модели}
\label{sec:specification}

Существует несколько способов формализации спецификации верифицируемой модели:
темпоральные логики, к которым относятся: логика линейного времени LTL (linear time
logic), логика ветвящего времени CTL (computation tree logic), CTL* (объединение LTL и
CTL), логика переменного времени ATL (alternating time logic), логика расширенного времени
ETL (extended time logic); мю-исчисление; язык спецификации утверждений PSL.

Одной из наиболее выразительных и при этом удобной для понимания!!!ссылка!!! являеется
CTL*, объединяющая в себе логику линейного и ветвящегося времени.

Темпоральные логики позволяют описывать последовательности переходов между состояниями
системы. В перечисленных логиках, несмотря на название, время напрямую неиспользуется;
вместо этого используются утверждения, что некоторое состояние \emph{когда-либо будет}
достигнуто или что оно \emph{никогда не будет} достигнуто. Такие утверждения записываются
при помощи \emph{темпоральных операторов}, которые можно объединять булевыми
связками. Между собой темпоральные логики отличаются в основном набором доступных
операторов.

Формулы в CTL* составляются из атомарных утверждений, темпоральных операторов и
\emph{кванторов пути}. В CTL* имеется два квантора:

\begin{itemize}
\item $\mathbf{A}$ (all)~--- <<для всех путей, выходящих из данного состояния>>,
\item $\mathbf{E}$ (exists)~--- <<существует такой путь, выходящий из данного состояния>>
\end{itemize}

\noindent и 5 операторов:

\begin{itemize}
\item $\mathbf{F}$ (finally)~--- <<рано или поздно в пути встретится состояние, в котором
  выполняется указанное утверждение>>,
\item $\mathbf{G}$ (globally)~--- <<во всех состояниях пути выполняется указанное
  утверждение>>,
\item $\mathbf{X}$ (next)~--- <<в следующем состояния пути выполняется указанное
  утверждение>>,
\item $\mathbf{U}$ (until)~--- <<пока в пути не появится состояние, в котором выполняется
  второе утверждение, во всех состояниях должно выполняться первое утверждение>>.
\end{itemize}

Например, формула $\mathbf{AFG}~ x$ означает <<во всех путях, идущих из начального
состояния, с некоторого состояния на протяжении всего пути выполняется $x$>>, а формула
$\mathbf{AGEF}~ x$ означает <<во всех путях, идущих из начального состояния, из каждого
состояния есть хотя бы один путь, в котором рано или поздно встретится состояние, в
котором выполняется $x$>>.

В CTL* выделяют два собственных пересекающихся подможества: логику линейного времени LTL и
логику ветвящегося времени CTL, объединение которых составляет саму CTL*. Различие между
ними заключается в допустимых комбинациях кванторов пути и темпоральных операторов. 

Логика линейного времени LTL состоит из формул вида $\mathbf{A}~f$, где $f$ не содержит
кванторов пути, только атомарные утверждения и темпоральные операторы. Примерами
LTL-формул являются $\mathbf{F}~x~\mathbf{U}~y$, $\mathbf{G}~x \Rightarrow \mathbf{F}~y$
($\mathbf{A}$ в начале обычно опускается).

Логика ветвящегося времени CTL состоит из формул, где кванторы пути чередуются с
темпоральными операторами (т.е. перед каждым темпоральным оператором должен стоять квантор
пути). Примерами CTL-формул являются $\mathbf{AG}~\mathbf{EF}~x$, $\mathbf{AG} x
\Rightarrow \mathbf{EF} y$.

Можно сказать, что LTL-формулы представляют собой утверждения относительно событий,
происходящих на каждом возможном пути в модели $M$, отсюда название <<логика
\emph{линейного} времени>>. В то же время, CTL-формулы представляют собой утверждения о
наличии выбора пути в определенных состояниях, приводящего к желаемому результату.

\section{Применение проверки на модели}
\label{sec:applications}

!!! описать, что на практике !!!

!!! Intel, использование CTL

\section{Проблемы проверки на модели}
\label{sec:problems}

!!! проблемы построения структуры Крипке

!!! проблемы верификации временной логики

\section{Проделанная работа}
\label{sec:my-work}

\section{Существующие работы по данному направлению}
\label{sec:other-work}

!!! существулющие работы по LTL

!!! отсутствие работ по CTL

\bibliographystyle{../thesis/gost780u}
\bibliography{../thesis/thesis}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
