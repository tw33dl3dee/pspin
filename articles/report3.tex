\documentclass[a4paper,12pt,notitlepage]{article}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{textcomp}
\usepackage{indentfirst}
\usepackage{verbatim}

\sloppy

\begin{document}

\section{Доклад}

\emph{(слайд 2)} \emph{Проверкой модели} называется автоматический формальный подход, при
котором на основе дискретной детерминированной модели программы или комплекса программ
строится полное пространство состояний и на нем делается проверка определенных
утверждений.

Проверку моделей можно использовать для поиска взаимоблокировок в параллельных алгоритмах
и ошибок в спецификациях сетевых протоколов. В качестве примера можно привести протокол
маршрутизации RIP: проверка модели из 4 маршрутизаторов, соединенных 4-мя сетями, на
предмет возникновения циклов в маршрутных таблицах позволяет убедиться, что существуют
сценарии, при которых такие циклы возникают, и необходимо использование специальных мер
для их избежания.

При росте числа и сложности компонент моделируемой системы наблюдается комбинаторный рост
числа возможных состояний, поэтому проверка модели требует больших затрат выч. ресурсов.

\emph{(слайд 3)} В данной работе предлагается параллельная генерация состояний конечной
модели с целью задействования ресурсов вычислительных кластеров. Целью является разработка
и исследование метода параллельной генерации состояний конечной детерминированной
модели. На слайде приведенные основные решаемые задачи.

\emph{(слайд 4)} Множество состояний программы или программного комплекса можно
формализовать как модель (\emph{структуру?..}) Крипке. МК представляет собой граф всех
состояний системы, дуги которого~--- переходы между ними. Каждое состояние характеризуется
набором значений переменных отдельных компонент системы и общих переменных
(\emph{используемых для взаимодействия?}).

\emph{(слайд 5)} В существущем подходе при проверке модели выполняется обход этого графа в
глубину или в ширину. Поскольку граф в общем случае содержит циклы, необходимо хранить
множество посещенных состояний. Для приведенной в качестве примера модели из 4
маршрутизаторов число состояний достигает $10^9$. При проверке моделе большего размера
множество посещенных состояний невозможно хранить явно в оперативной памяти одной машины,
а использование внешней памяти замедляет скорость проверки на 3--4 порядка.

Существует ряд оптимизаций для решения этой проблемы, однако все они имеют недостатки и
ограничения, поэтому в данной работе предлагается иное решение~--- параллельная генерация
состояний и хранение их на различных узлах выч. сети.

\emph{(слайд 6)} Разработаны два алгоритма параллельной генерации состояний и их
хранения. При первом, <<распределенном хранении>>, собственно генерацией занимается лишь
головной узел, а остальные узлы используются вместе с ним для хранения состояний. Для
проверки, принадлежит ли следующее состояние множеству посещенных, делается синхронный
удаленный вызов хранящего это состояние узла.

\emph{(слайд 7)} Пример работы алгоритма <<распредленного хранения>> показан на
слайде. Преимущество алгоритма в том, что сохраняется глобальный порядок обхода состояний,
что важно для проверок утверждений определенного
рода. % Однако, генерация каждого нового состояния приводит к
% синхронному удаленному вызову и используется вычислительная мощность лишь одного узла.

\emph{(слайд 8)} При втором алгоритме, <<распределенной генерации состояний>>, все узлы
равноправны и занимаются как хранением, так и генерацией состояний. Если новое состояние
принадлежит другому узлу, оно высылается ему асинхронным удаленным вызовом. 

\emph{(слайд 9)} Из примера работы алгоритма <<распределенной генерации>> видно, что
какой-либо глобальный порядок обхода состояний при этом не сохраняется, что огранивает
возможные классы проверяемых утверждений. Однако, используется выч. мощность всех узлов и
все удаленные вызовы являются асинхронными, что является преимуществом перед первым
алгоритмом в тех случаях, когда глобальный порядок обхода не имеет значения.

\emph{(слайд 10)} Если следующее состояние принадлежит тому же узлу, что и предыдущее,
удаленного вызова не происходит. Правильный выбор функции распределения состояний между
узлами, обладающей свойством локальности, может сократить число удаленных вызовов. В то же
время, для эффективного использования памяти узлов, состояния должны распределяться между
узлами как можно более равномерно.

Тривиальным решением будет использовать хэш-код от всей структуры состояния как индекс
узла, который хранит это состояние (показано на слайде сверху). Это обеспечит достаточно
равномерное число состояний, однако локальность нарушается~--- из формулы сверху видно,
что с ростом числа узлов число передаваемых между ними сообщений приближается к числу
переходов, т.е. почти каждое новое состояние будет принадлежать другому узлу.

Вместо наивного подхода предлагается улучшенный. Структура состояния представляет собой
набор состояний отдельных компонент и какие-то общие переменные, и можно в качестве
индекса узла использовать хэш-код не всего состояния целиком, а его части, соответствующей
переменным первой компоненты либо нескольких компонент. При таком распределении,
показанном в нижней части слайда, удаленный вызов будет происходить лишь при переходах,
затрагивающих изменение переменных этих компонент.

\emph{(слайд 11)} Для хранения состояний в памяти узла используется хэш-таблица с открытой
адресацией, хранящая указатели на структуры состояний. Множество уже посещенных состояний
хранится при этом совместно с очередью поиска в ширину, и граница между ними смещается по
мере обработки новых состояний.

\emph{(слайд 12)} \emph{Переход к проектированию ПО}. На слайде показаны основные
компоненты разработанного ПО. Транслятор описания модели переводит входное описание во
внутренний вид в виде двух функций~--- переходов модели, сопоставляющей каждому состоянию
множество связанных с ним отношением перехода на графе состояний, и функции проверки
состояний, проверяющую выполнение заданных утверждений для текущего состояния по мере
обхода графа.

\emph{(слайд 13)} Генератор состояний, использую полученную функцию переходов модели,
выполняет обход по графу состояний. \emph{(мало!!)}

\emph{(слайд 14)} В качестве платформы для параллельных вычислений используется MPI. Для
передачи сообщений используются асинхронные примитивы, разработана собственная библиотека
для работы с очередью асинхронных запросов. Пример последовательности действий при
взаимодействии двух MPI-процессов показан на слайде.

\emph{(слайд 15)} В качестве языка для описания исходной модели выбран язык Promela,
используемый в существующем ПО Spin. Компоненты системы в языке Promela представляется в
виде взаимодействующих друг с другом процессов. Каждый процесс-компонент состоит из
последовательности инструкций, имеющих каждая условие выполнимости и действие.

Для достижения скорости перебора состояний, сравнимой с существующим ПО, при трансляции
исходной модели используется генерация кода на языке~С. Исходная модель переводится с
языка Promela во внутреннее представление в виде графа команд, показанного на слайде, на
основе которого генерируется код функции переходов.

\emph{(слайд 16)} В ходе исследования проводится сравнение созданного ПО с существующим ПО
Spin и сравнение двух предложенных способов распределения состояний между
узлами. \emph{(слайд 17)} Эксперименты проводились для двух моделей: обедающих философов и
распределенного алгоритма выбора лидера с различным числом сторон. Для экспериментов
использовался кластер, состоящий из 80 узлов с объемом памяти по 4 Гб каждый.

\emph{(слайд 18)} В первом эксперименте показана зависимость требуемого для проверки
модели времени от числа ее состояний. На небольших моделях, имеющих до $10^7$ состояний,
разработанное ПО требует того же порядка времени, что и ПО Spin. При дальнейшем росте
числа состояний проверка при помощи ПО Spin становится невозможной, тогда как
разработанное ПО позволило проверить модели, имеющие более $10^{10}$ состояний.

% \emph{(слайд 22)} В следующем эксперименте проводится сравнении скорости генерации
% состояний ПО Spin и разработанного ПО без учета сетевых задержек. Целью эксперимента
% является проверка качественности генерируемого кода. Скорость генерации состояний сравнима
% со скоростью Spin.

\emph{(слайд 19)} Следующий эксперимент~--- по сравнению предложенных способов
распределения состояний. Сравнивается использование хэш-кода всего состояния, состояний
одной и двух компонент. В таблицах показана доля передаваемых между узлами сообщений среди
всех переходов, степень неравномерность распределения состояний между узлами и время
простоя/выполнения.

Из графиков видно, что тривиальное распределение при помощи хэш-кода от всего состояния
действительно обспечивает высокую равномерность, но число сообщений между узлами при этом
близко к числу переходов во всей модели. Б\'{о}льшую часть времени выполнения составляет
время простоя из-за сетевых задержек при ожидании сообщений от других узлов и при посылке.

Если использовать хэш-код лишь состояния одного компонента, то, хотя и достигается
уменьшение числа сообщений и времени работы в 5--6 раз, неравномерность распределения
становится высокой~--- память на некоторых узлах почти не используется. Использование
хэш-кода от двух компонент является компромиссным вариантом, сочетающим 2--3-х кратное
уменьшение времени работы с неравномерностью распределения не выше 30\%.

\emph{(слайд 20)} Выводы. Разработанный метод и реализованное ПО может использоваться для
проверки моделей с большим числом состояний, чем позволяет имеющееся. Предложено
распределение состояний между узлами, позволяющее сократить число передаваемых сообщений
и, как следствие, время работы.

По результатам работы имеется одна публикация.

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
