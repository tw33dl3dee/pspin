\documentclass[a4paper,12pt,notitlepage]{article}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{textcomp}
\usepackage{indentfirst}
\usepackage{verbatim}

\sloppy

\begin{document}

\section{Доклад}

\emph{(слайд 2)} \emph{Проверкой модели} называется автоматический формальных подход, при
котором составляется конечная дискретная детерминированная модель программы или комплекса
программ, для нее строится полное пространство состояний и на нем делается проверка
интересующих нас утверждений. Таким образом можно выявить взаимоблокировки в параллельных
алгоритмах и ошибки в спецификации сетевых протоколов.

Примером такой модели может служить модель домена маршрутизации (\textbf{>\_<}) из 4
маршуртизаторов, обменивающихся сообщениями протокола RIP и соединенных 4-мя различными
сетями, а проверяемым утверждением~--- отсутствие циклов маршрутизации. Проверка модели
позволяет установить, что без использования техники <<расщепленного горизонта>> в
протоколе RIP такой цикл может возникнуть.

Из-за комбинаторного роста числа возможных состояний при росте числа и сложности компонент
моделируемой системы проверка модели требует больших объемов памяти и времени.

\emph{(слайд 3)} В данной работе предлагается параллельная генерация состояний конечной
модели с целью задействования ресурсов вычислительных кластеров. Целью работы является
разработка и исследование метода параллельной генерации состояний конечной
детерминированной модели. На слайде приведенные основные решаемые задачи.

\emph{(слайд 4)} Множество состояний программы или программного комплекса можно
формализовать как модель (\emph{структуры?..}) Крипке. МК представляет собой граф всех
состояний системы, дуги которого~--- переходы между ними. Каждое состояние характеризуется
набором значений переменных и состояний отдельных компонент системы.

\emph{(слайд 5)} В существущем подходе при проверке модели выполняется обход этого графа в
глубину или ширину. Поскольку граф в общем случае циклический, необходимо хранить
множество посещенных состояний. Для приведенной в качестве примера модели из 4
маршрутизаторов число состояний достигает $10^9$, поэтому при проверке б\'{о}льших моделей
множество посещенных состояний невозможно хранить явно в оперативной памяти одной машины,
а использование внешней памяти замедляет скорость проверки на 3--4 порядка.

Существует ряд оптимизаций для решения этой проблемы, однако все они имеют недостатки и
ограничения, поэтому в данной работе предлагается иное решение~--- параллельная генерация
состояний с их хранением на различных узлах выч. сети.

\emph{(слайд 6)} Разработано два алгоритма параллельной генерации состояний и их
хранения. При первом, <<распределенном хранении>>, собственно генерацией занимается лишь
головной узел, а остальные узлы используются вместе с ним для хранения состояний. Для
проверки, принадлежит ли следующее состояние множеству посещенных, делается синхронный
удаленный вызов хранящего это состояние узла.

\emph{(слайд 7)} На следующем слайде показан пример его работы. Преимущество алгоритма в
том, что сохраняется глобальный порядок обхода состояний, что важно для проверок
утверждений определенного рода. Однако, генерация каждого нового состояния приводит к
синхронному удаленному вызову и используется вычислительная мощность лишь одного узла.

\emph{(слайд 8)} При втором алгоритме, <<распределенной генерации состояний>>, все узлы
равноправны и занимаются как хранением, так и генерацией состояний. Если новое состояние
принадлежит другому узлу, оно высылается ему асинхронным удаленным вызовом. 

\emph{(слайд 9)} Из примера работы этого алгоритма видно, что какой-либо глобальный
порядок обхода состояний при этом не сохраняется, что огранивает возможные классы
проверяемых утверждений. Однако при этом используется выч. мощность всех узлов и все
удаленные вызовы являются асинхронными.

\emph{(слайд 10)} Если следующее состояние принадлежит тому же узлу, что и предыдущее, в
удаленном вызова не происходит. Правильный выбор функции распределения состояний между
узлами, облающающей свойством локальности, может сократить число удаленных вызовов. В то
же время, для эффективного использования ОЗУ узлов, состояния должны распределяться как
можно более равномерно.

Тривиальным решением будет использовать хэш-код от всей структуры состояния как индекс
узла, который хранит это состояние (показано на слайде сверху). Это обеспечит достаточно
равномерное число состояний, однако локальность при этом нарушается~--- из формулы сверху
видно, что с ростом числа узлов число сообщений между узлами приближается к числу
переходов, т.е. почти каждое новое состояние будет принадлежать другому узлу.

Предложен другой подход. Структура состояния представляет собой набор состояний отдельных
компонент и какие-то общие переменные, и можно в качестве индекса узла использовать
хэш-код не всего состояния целиком, а его части, соответствующей переменным первой
компоненты либо нескольких компонент. При таком распределении удаленный вызов будет
происходить лишь при переходах, затрагивающих эти компоненты.

\emph{(слайд 11)} Для хранения состояний в памяти узла используется хэш-таблица с открытой
адресацией, хранящая указатели на структуры состояний. Множество уже посещенных состояний
хранится при этом совместно с очередью поиска в ширину, и граница между ними смещается по
мере обработки новых состояний.

\emph{(слайд 12)} \emph{Переход к проектированию ПО}. На слайде показаны основные
компоненты разработанного ПО. Транслятор описания модели переводит входное описание модели
во внутренний вид в виде двух функций~--- переходов модели, сопоставляющей каждому
состоянию множество связанных с ним отношением перехода на графе состояний, и функции
проверки состояний, проверяющую выполнение заданных утверждений для состояний по мере
обхода графа.

\emph{(слайд 13)} Генератор состояний, использую полученную функцию переходов модели,
выполняет обход по графу состояний. \emph{(мало!!)}

\emph{(слайд 14)} В качестве платформы для параллельных вычислений используется MPI. Для
передачи сообщений используются асинхронные примитивы, разработана собственная библиотека
для работы с очередью асинхронных запросов. Пример последовательности действий при
взаимодействии двух MPI-процессов показан на слайде.

\emph{(слайд 15)} В качестве языка для описания исходной модели выбран язык Promela,
используемый в существующем ПО Spin. Модель в Promela представляется в виде
взаимодействующих друг с другом процессов, каждый процесс состоит из последовательности
инструкций, имеющих каждая свое условие выполнимости и результат выполнения. 

Для достижения скорости перебора состояний, сравнимой с существующим ПО, при трансляции
исходной модели используется генерация кода на языке~С. Исходная модель на языке Promela
переводится во внутреннее представление в виде графа команд, показанного на слайде, на
основе которого генерируется код функции переходов.

\emph{(слайд 16)} В ходе исследования проводится сравнение созданного ПО с существующим ПО
Spin и сравнение двух предложенных способов распределения состояний между
узлами. \emph{(слайд 17)} Эксперименты проводились для двух моделей: обедающих философов и
распределенного алгоритма выбора лидера с различным числом сторон. Эксперименты
проводились на кластере, имеющем 80 узлов с объемом памяти по 4 Гб каждый.

\emph{(слайд 18)} В первом эксперименте показана зависимость требуемого для проверки
модели времени от числа ее состояний. На небольших моделях, имеющих до $10^7$ состояний,
разработанное ПО требует того же порядка времени, что и Spin. При дальнейшем росте числа
состояний проверка при помощи ПО Spin становится невозможной, тогда как разработанное ПО
позволило проверить модели, имеющие более $10^{10}$ состояний.

% \emph{(слайд 22)} В следующем эксперименте проводится сравнении скорости генерации
% состояний ПО Spin и разработанного ПО без учета сетевых задержек. Целью эксперимента
% является проверка качественности генерируемого кода. Скорость генерации состояний сравнима
% со скоростью Spin.

\emph{(слайд 19)} Следующий эксперимент~--- по сравнению предложенных способов
распределения состояний. Сравнивается использование хэш-кода всего состояния, состояний
одной и двух компонент. В таблицах показана доля передаваемых между узлами сообщений среди
всех переходов, неравномерность распределения состояний между узлами и время
простоя/выполнения.

Из графиков видно, что тривиальное распределение при помощи хэш-кода от всего состояния
действительно обспечивает высокую равномерность, но число сообщений между узлами при этом
близко к числу переходов во всей модели и. Большую часть времени выполнения занимает
простой из-за сетевых задержек.

Если использовать хэш-код лишь состояния одного компонента, то, несмотря на уменьшения
числа сообщений и времени работы в 5--6 раз, неравномерность распределения становится
высокой~--- память на некоторых узлах почти не используется. Использование хэш-кода от
двух компонент является компромиссным вариантов, сочетающим 2--3-х кратное уменьшение
времени работы с неравномерностью распределения не выше 30\%.

\emph{(слайд 20)} Выводы. Разработанное ПО может использоваться для проверки моделей с
большим числом состояний, чем позволяет имеющееся. Предложено распределение состояний
между узлами, позволяющее сократить число сообщений между узлами и время работы.

По результатам работы имеется одна публикация.

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
