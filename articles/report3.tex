\documentclass[a4paper,12pt,notitlepage]{article}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{textcomp}
\usepackage{indentfirst}
\usepackage{verbatim}

\sloppy

\begin{document}

\section{Доклад}


% При разработке параллельных алгоритмов и протоколов взаимодействия возникает задача их
% проверки на соответствие определённым спецификациям, таким, как отсутствие
% взаимоблокировок и других критических ситуаций.

\emph{(слайд 2)} Тестирование ПО позволяет выявить не все ошибки, а лишь часто
встречающиеся. В то же время, определённые классы ошибок требуется полностью исключить,
поскольку при большом числе инсталляций или при многолетней работе системы даже
маловеротятные ошибки могут проявится.

Для их выявления применяется автоматический формальных подход, называемый \emph{проверкой
  свойств модели}. Составляется дискретная модель проверяемой параллельной системы или
протокола, для которой строится полное пространство состояний и на нем делается проверка
интересующих нас утверждений.

\emph{(слайд 3)} Поскольку число состояний модели может быть весьма велико, то в данной
работе предлагается параллельная генерация состояний с целью задействования ресурсов
вычислительных кластеров.

Целью работы является разработка и исследование метода параллельной генерации состояний
конечной детерминированной модели. На слайде приведенные основные решаемые задачи.

\emph{(слайд 4)} В качестве модели отдельного процесса в параллельной системе или
участника сетевого протокола может использоваться автомат Мили. Приведён пример такого
автомата для одного философа из задачи об обедающих философах.

%Состояниями автомата являются отдельные этапы выполнения процесса. События, которых
%процесс или участник ожидает, обозначаются входными последовательностями переходов, а
%выполняемые атомарные действия~--- выходными.

% В качестве примера приведен автомат Мили, представляющий поведение философа из задачи об
% обедающих философах. Начальным состоянием философа является <<размышление>>. Из него, если
% левая вилка свободна, он может перейти в состояние <<держит 1 вилку>>, выполняя при этом
% атомарное действие <<взять вилку>>. Затем, при выполнении условия <<правая вилка
% свободна>>, философ совершает действие <<взять правую вилку>>, после которого оказывется в
% состоянии <<ест>>. Какие-то конкретные ограничений на то, сколько философ должен есть, в
% примере отсутсвуют, поэтому из состояния <<ест>> философ в любой момент спонтанно (т.е. по
% пустому событию True) переходит в начальное состояние <<размышляет>>, выполняя действие
% <<положить обе вилки>>.

Параллельную систему целиком можно представить, как объединение автоматов Мили,
описывающих каждый из участвующих процессов. Однако, такое описание мало пригодно для
непосредственной проверки утверждений о работе системы. Для этого можно использовать
другой способ ее формального представления, называемый моделью Крипке. \emph{(слайд 5)}

Модель Крипке представляет собой граф, содержащий все возможные состояния системы и
переходы между ними. Каждое состояние характеризуется набором значений переменных и
состояниями входящих в нее автоматов.

\emph{(слайд 6)} На слайде представлена модель Крипке для системы из двух
философов. Темным тоном выделено состояние взаимной блокировки.

\emph{(слайд 7)} Наиболее распространненым средством автоматической проверки свойств
модели является ПО Spin, использующее для описания моделей язык Promela, пример
использования которого приведен на данном слайде.

\emph{(слайд 8)} Хранить целиком пространство состояний в ОЗУ одной машины часто
невозможно даже для моделей среднего размера. В настоящее время применяется ряд
оптимизаций, как сокращающих число самих состояний, так и объем памяти, необходимый для их
хранения. В данной работе предлагается использовать параллельную генерацию с
распределением состояний между несколькими вычислительными узлами.

Для создания ПО для парраллельной генерации состояний необходимо разработать алгоритмы
параллельной генерации состояний и их хранения.

\emph{(слайд 9)} Разработано два алгоритма. При первом, распределенном хранении,
собственно генерацией занимается лишь головной узел, а остальные узлы используются вместе
с ним для хранения состояний. \emph{(слайд 10)} На следующем слайде показан пример его
работы. Может использоваться тот порядок генерации, который необходим~--- в глубину, как
на слайде, или в ширину, что позволяет проверять утверждения различного типа.

\emph{(слайд 11)} На слайде приведен псевдокод второго алгоритма, распределенной
генерации состояний. В нем генерацией состояний занимается каждый узел. Если
сгенерированное состояние принадлежит другому узлу, оно высылается ему асинхронным
удаленным вызовом. \emph{(слайд 12)} Следующий слайд содержит пример его работы
алгоритма. Какой-либо глобальный порядок обхода состояний при этом не сохраняется, что
огранивает возможные классы проверяемых утверждений, однако, в отличие от предыдущего
случая, используется выч. мощность всех узлов, все удаленные вызовы являются асинхронными
и возможно распределение состояний между узлами, уменьшающее число удаленных вызовов.

\emph{(слайд 13)} \emph{Сказать, почему необходимо хранить в памяти}. Простейшим
способом распределения состояний между узлами является использование хэш-кода всего
состояния модели в качестве номера хранящего ее узла. Предлагается другой вариант:
использовать хэш-код первого или первых $N$ процессов. Ожидается, что это позволить
уменьшить число удаленных вызовов при генерации состояний без серьезного ухудшения
равномерности распределения.

\emph{(слайд 14)} Для хранения состояний в памяти узла используется хэш-таблица с открытой
адресацией, хранящая указатели на состояния. Множество уже посещенных состояний хранится
совместно с очередью поиска в ширину.

\emph{(слайд 15)} \emph{Переход к проектированию ПО}. На следующем слайде показаны
основные компоненты реализованного параллельного генератора.

\emph{(слайд 16)} В качестве платформы для параллельных вычислений используется MPI.
\emph{(слайд 17)} \emph{Напомнить, для чего кластер}. Для передачи сообщений используются
асинхронные примитивы MPI, разработана собственная библиотека для работы с очередью
асинхронных запросов. Пример последовательности действий при взаимодействии двух
MPI-процессов показан на след. слайде \emph{(слайд 18)}.

\emph{(слайд 19)} \emph{Пояснить необходимость транслятора}. Реализован транслятор описания
модели на языке Promela в код С, реализующий функцию переходов модели, необходимую для
работы генератора. Исходная модель на языке Promela транслирует во внутреннее
представление в виде графа команд, имеющих условия выполнимости и действия выполнения.

\emph{(слайд 20)} В экспериментах проводится сравнение созданного ПО с существующим ПО
Spin, а также сравнение двух предложенных методов распределения состояний между
узлами. Эксперименты проводились для двух моделей: обедающих философов и распределенного
алгоритма выбора лидера.

\emph{(слайд 21)} В первом эксперименте показана зависимость требуемого для проверки
модели времени от числа ее состояний. Объем памяти каждого узла составляет 4 Гб,
использовалось от 4 до 80 узлов. На небольших моделях, имеющих до $10^7$ состояний,
разработанное ПО требует того же порядка времени, что и Spin. При дальнейшем рости числа
состояний проверка при помощи ПО Spin становится невозможной, разработанное ПО позволило
проверить модели, имеющие более $10^{10}$ состояний, при этом время растет линейно с
числом состояний.

\emph{(слайд 22)} В следующем эксперименте проводится сравнении скорости генерации
состояний ПО Spin и разработанного ПО без учета сетевых задержек. Целью эксперимента
является проверка качественности генерируемого кода. Скорость генерации состояний сравнима
со скоростью Spin.

\emph{(слайд 23)} Наконец, проводен эксперимент по сравнению предложенных способов
распределения состояний. В таблицах показана доля передаваемых между узлами сообщений
среди всех переходов, неравномерность распределения состояний между узлами и время
простоя/выполнения. Из эксперимента следует, что предложенный улучшенный вариант
распределения позволяет в несколько раз уменьшить число удаленных вызовов и требуемое
время. При использовании хэш-кода лишь одного процесса распределение получается
неравномерным, поэтому целесообразно использовать хэш-код двух процессов, являющийся
компромиссом между скоростью и равномерность.

\emph{Общий вывод по экспериментам}.

\emph{(слайд 24)} Выводы. 
\begin{enumerate}
\item Проанализированы проблемы проверки моделей и существующие подходы к их решению
\item Спроектирован и реализован алгоритм параллельной генерации состояний конечной
  модели
\item Предложен метод автоматического распределения состояний, уменьшающий число сообщений
  между узлами
\item Проведены эксперименты и проанализированы их результаты
\end{enumerate}

По результатам работы имеется одна публикация.

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
