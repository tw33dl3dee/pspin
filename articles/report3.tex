\documentclass[a4paper,12pt,notitlepage]{article}

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english,russian]{babel}

\usepackage{textcomp}
\usepackage{indentfirst}
\usepackage{verbatim}

\sloppy

\begin{document}

\section{Доклад}


При разработке параллельных алгоритмов и протоколов взаимодействия возникает задача их
проверки на соответствие определённым спецификациям, таким, как отсутствие
взаимоблокировок и других критических ситуаций.

\emph{(слайд 2)} Тестирование ПО позволяет выявить не все ошибки, а лишь часто
встречающиеся. В то же время, определённые классы ошибок требуется полностью
исключить. Например, если новое расширение сетевого протокола приводит к потере данных
только в $10^{-3}\%$ случаев, это может остаться не выявленным при тестировании, однако
при использовании на 100 млн. машин приведёт к потерям на 1000 из них, что уже довольно
много.

Для их выявления применяется автоматический формальных подход, называемый \emph{проверкой
  свойств модели}. Составляется дискретная модель проверяемой параллельной системы или
протокола, для которой строится полное пространство состояний и на нем делается проверка
интересующих нас утверждений.

Поскольку размер пространства состояний модели растет экспоненциально, даже для среднего
размера моделей оно насчитывает до $10^9 - 10^{10}$ состояний. \emph{(слайд 3)} В данной
работе предлагается параллельная генерация состояний несколькими узлами вычислительной
сети с распределением хранения состояний между ними.

Целью работы является разработка и исследование метода параллельной генерации состояний
конечной детерминированной модели.

Для достижения поставленной цели необходимо:
\begin{enumerate}
\item проанализировать проблемы проверки моделей и существующие подходы к их решению;
\item разработать и реализовать алгоритм параллельной генерации состояний;
\item спроектировать метод автоматического распределения состояний между узлами;
\item провести эксперименты и проанализировать их результаты.
\end{enumerate}

\emph{(слайд 4)} Работу отдельного процесса в параллельной системе или участника протокола
можно представить в виде автомата Мили. Состояниями автомата являются отдельные этапы
выполнения процесса. События, которых процесс или участник ожидает, обозначаются входными
последовательностями переходов, а выполняемые атомарные действия~--- выходными.

% В качестве примера приведен автомат Мили, представляющий поведение философа из задачи об
% обедающих философах. Начальным состоянием философа является <<размышление>>. Из него, если
% левая вилка свободна, он может перейти в состояние <<держит 1 вилку>>, выполняя при этом
% атомарное действие <<взять вилку>>. Затем, при выполнении условия <<правая вилка
% свободна>>, философ совершает действие <<взять правую вилку>>, после которого оказывется в
% состоянии <<ест>>. Какие-то конкретные ограничений на то, сколько философ должен есть, в
% примере отсутсвуют, поэтому из состояния <<ест>> философ в любой момент спонтанно (т.е. по
% пустому событию True) переходит в начальное состояние <<размышляет>>, выполняя действие
% <<положить обе вилки>>.

Параллельную систему целиком можно представить, как объединение автоматов Мили,
описывающих каждый из участвующих процессов. Однако, такое описание тяжело использовать
для проверки каких-либо утверждений о системе. Для этого можно использовать другой способ
ее формального представления, называемый моделью Крипке. \emph{(слайд 5)}

Нужно ли зачитать определение?

\emph{(слайд 6)} На слайде представлена модель Крипке для системы из двух
философов. Цветом выделено состояние взаимной блокировки.

\emph{(слайд 7)} Наиболее распространненым средством автоматической проверки свойств
модели является ПО Spin, использующее для описания моделей язык Promela. В качестве
примера на слайде приведено описание модели из пяти обедающих философов на этом языке.

\emph{(слайд 8)} Основной проблемой проверки конечных моделей является экспоненциальный
рост числа состояний, приводящий к тому, что даже для моделей среднего размера его
невозможно напрямую хранить в памяти одной машины. В ПО Spin применяется ряд оптимизаций,
как сокращающих число самих состояний, так и объем памяти, необходимый для их хранения. В
данной работе предлагается использовать параллельную генерацию с распределением состояний
между несколькими вычислительными узлами.

\emph{(слайд 9)} Разработано два алгоритма параллельной генерации состояний. При первом,
распределенном хранении, собственно генерацией занимается лишь головной узел, а остальные
узлы используются вместе с ним для хранения состояний. \emph{(слайд 10)} На следующем
слайде показан пример его работы. Может использоваться тот порядок генерации, который
необходим~--- в глубину, как на слайде, или в ширину, что позволяет проверять утверждения
различного типа.

\emph{(слайд 11)} На следующем слайде~--- псевдокод второго алгоритма, распределенной
генерации состояний. В нем генерацией состояний занимается каждый узел. Если
сгенерированное состояние принадлежит другому узлу, оно высылается ему асинхронным
удаленным вызовом. \emph{(слайд 12)} Следующий слайд содержит пример его работы
алгоритма. Какой-либо глобальный порядок обхода состояний при этом не сохраняется, что
огранивает возможные классы проверяемых утверждений, однако, в отличие от предыдущего
случая, используется выч. мощность всех узлов, все удаленные вызовы являются асинхронными
и возможно распределение состояний между узлами, уменьшающее число удаленных вызовов.

\emph{(слайд 13)} Простейшим способом распределения состояний между узлами является
использование хэш-кода всего состояния модели в качестве номера хранящего ее
узла. Предлагается другой вариант: использовать хэш-код первого или первых $N$
процессов. Ожидается, что это позволить уменьшить число удаленных вызовов при генерации
состояний без серьезного ухудшения равномерности распределения.

\emph{(слайд 14)} Для хранения состояний в памяти узла используется хэш-таблица с открытой
адресацией, хранящая указатели на состояния. Множество уже посещенных состояний хранится
совместно с очередью поиска в ширину.

\emph{(слайд 15)} На следующем слайде показаны основные компоненты реализованного
параллельного генератора.

\emph{(слайд 16)} В качестве платформы для параллельных вычислений используется MPI.
\emph{(слайд 17)} Для передачи сообщений используются асинхронные примитивы MPI,
разработана собственная библиотека для работы с очередью асинхронных
запросов. Пример последовательности действий при взаимодействии двух MPI-процессов показан
на след. слайде \emph{(слайд 18)}.

\emph{(слайд 19)} Реализован транслятор описания модели на языке Promela в код С,
реализующий функцию переходов модели, необходимую для работы генератора. Исходная модель
на языке Promela транслирует во внутреннее представление в виде графа команд, имеющих
условия выполнимости и действия выполнения.

\emph{(слайд 20)} В экспериментах проводится сравнение созданного ПО с существующим ПО
Spin, а также сравнение двух предложенных методов распределения состояний между узлами. В
качестве исходных данных используются две модели, модель обедающих философов и
распределенный алгоритм выбора лидера.

\emph{(слайд 21)} В первом эксперименте показана зависимость требуемого для проверки
модели времени от числа ее состояний. На небольших моделях, имеющих до $10^7$ состояний,
разработанное ПО требует того же порядка времени, что и Spin. При дальнейшем рости числа
состояний проверка при помощи ПО Spin становится невозможной, разработанное ПО позволило
проверить модели, имеющие более $10^{10}$ состояний, при этом время растет линейно с
числом состояний.

\emph{(слайд 22)} В следующем эксперименте проводится сравнении скорости генерации
состояний ПО Spin и разработанного ПО без учета сетевых задержек. Целью эксперимента
является проверка качественности трансляции модели на языке Promela в код. Скорость
генерации состояний сравнима со скоростью Spin.

\emph{(слайд 23)} Наконец, проводится эксперимент по сравнению предложенных способов
распределения состояний. В таблицах показана доля передаваемых между узлами сообщений
среди всех переходов, неравномерность распределения состояний между узлами и время
простоя/выполнения. Из эксперимента следует, что предложенный улучшенный вариант
распределения позволяет в несколько раз уменьшить число удаленных вызовов и требуемое
время. При использовании хэш-кода лишь одного процесса распределение получается
неравномерным, поэтому целесообразно использовать хэш-код двух процессов, являющийся
компромиссом между скоростью и равномерность.

\emph{(слайд 24)} Выводы. 
\begin{enumerate}
\item Проанализированы проблемы проверки моделей и существующие подходы к их решению
\item Спроектирован и реализован алгоритм параллельной генерации состояний конечной
  модели
\item Предложен метод автоматического распределения состояний, уменьшающий число сообщений
  между узлами
\item Проведены эксперименты и проанализированы их результаты
\end{enumerate}

По результатам работы имеется одна публикация.

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
