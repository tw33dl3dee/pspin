\documentclass[utf8]{G7-32}

\sloppy 

\EqInChapter
\TableInChapter
\PicInChapter

\usepackage[
bookmarks=true, colorlinks=true, unicode=true,
urlcolor=black,linkcolor=black, anchorcolor=black,
citecolor=black, menucolor=black, filecolor=bla,
]{hyperref}

\usepackage{cmap}       % теперь из pdf можно копипастить русский текст
\usepackage{underscore} % Ура! Теперь можно писать подчёркивание.
\usepackage{graphicx}	% Пакет для включения рисунков

\usefont{T2A}{ftm}{m}{} % Ужирнение начертания шрифта --- после чего
                        % выглдяит таймсоподобно и удобнее для чтения
                        % в плохих условиях.

\include{lib}

\begin{document}

\frontmatter

\begin{abstract}

\end{abstract}

\tableofcontents

\Abbreviations
\begin{description}
\item[МПХ] Мужской половой хуй.
\end{description}

\Introduction

При разработке параллельных алгоритмов и протоколов взаимодействия
часто возникает необходимость их верификации на соответствие
определённым условиям целостности. Например, параллельного алгоритма
не должен иметь взаимоблокировок, а в протоколе взаимодействия все
участвующие стороны должны всегда достигать конечного состояния.

Функциональное тестирование системы позволяет выявить не все ошибки, а
лишь наиболее часто встречающие. В то же время, определённые классы
ошибок требуется полностью исключить. Например, если новое расширение
сетевого протокола с улучшенным контролем трафика приводит к потере
данных только в $10^{-3}\%$ случаев, это может остаться не выявленным при
тестировании, однако при использовании на 100 млн. машин приведёт к
потерям на 1000 из них, что уже довольно много. Для их выявления и
подходит верификация самой модели, которая путем перебора всех
состояний системы проверит, возможен ли такой сценарий
функционирования системы, при котором она приходит в недопустимое
состояние.

Основным программным средством для подобной проверки конечных моделей
является \Term{SPIN}. Для описания модели в нем используется язык описания
Promela (\Term{PROtocol Meta Language}). 

При верификации модели SPIN выполняет исчерпывающий поиск в глубину по
пространству состояний и, при достижении недопустимого состояния,
сохраняет сценарий, приведший к приходу в это состояние.

Поскольку размер пространства состояний модели растет экспоненциально,
даже для среднего размера моделей оно насчитывает до $10^9 - 10^{10}$
состояний, требующих десятки гигабайт памяти для хранения множества
пройденных состояний. Это делает проверку больших моделей
нереализуемой практически. Для сокращения объема требуемой памяти
используются различные оптимизации — сжатие хранимых состояний,
битовое хэширование пространства состояний и т.д. В
данной работе предлагается другой подход — параллельное выполнение на
нескольких узлах вычислительной сети с распределением хранимых
состояний между ними.

\mainmatter

\chapter{Постановка задачи}
\label{cha:whats-this-about}

\chapter{Анализ существующих аналогов}
\label{cha:analogs}

\chapter{Последовательная генерация состояний}
\label{sec:seq-statespace}

\section{Алгоритм построения}
\label{sec:seq-algo}

Процесс обычного (последовательного) построения пространства состояний
можно рассмотреть на примере упомянутого ранее верификатора SPIN.

Модель конечной системы на языке Promela описывается в виде ряда
взаимодействующих процессов, обменивающихся сообщениями через каналы
ограниченной емкости. Состояние системы представляет собой набор
значений глобальных переменных и локальных состояний каждого из
процессов. Состояние процесса включает в себя его <<счетчик инструкций>>
и набор локальных переменных. Множество переходов из текущего
состояния представляет собой объединение возможных переходов для
каждого процесса из его локального состояния.

Пример модели на на этом языке, описывающей семафор Дейкстры и 3
процесса, захватывающих его:

\begin{CodeBlock}
mtype { p, v };
chan sema = [0] of { mtype };
active proctype Dijkstra()
{      byte count = 1;
       do
       :: (count == 1) ->
               sema!p; count--
       :: (count == 0) ->
               sema?v; count++
       od
}
active [3] proctype user()
{       do
        :: enter: sema?p; /* enter critical section */
            crit: skip;   /* critical section */
                  sema!v; /* leave critical section */
        od
}
\end{CodeBlock}

Последовательный алгоритм построения пространства состояний,
используемый верификатором SPIN, можно представить следующим
псевдокодом:

\begin{CodeBlock}
Visited = []
def StateSpaceDFS(state):
    if not state in Visited:
        Visited += state
        for each transition t from state:
            next_state = next state after t
            StateSpaceDFS(next_state)
StateSpaceDFS(start)
\end{CodeBlock}

Последовательное построение пространства состояний с ростом размера
модели быстро становится невозможным из-за нехватки памяти для
хранения множества достигнутых состояний (\Code{Visited}). Можно предложить
два решения проблемы: использование оптимизаций, сокращающих расход
памяти, и параллельная генерация состояний с распределением хранимых
состояний между различными узлами вычислительной сети.

\section{Битовое хэширование состояний}
\label{sec:bit-hashing}

Одной из оптимизаций, позволяющей сократить расходуемый объем памяти,
является так называемое битовое хэширование состояний (\Term{bit-state
hashing}). Суть его заключается в том, что вместо традиционной
хэш-таблицы, с открытой индексацией или со списками, для хранения
состояний используется битовая таблица. Каждое состояние \Code{S}
представлено в ней битом с номером \Code{i = hash(S)}. Нулевой бит означает,
что состояние еще не было достигнуто, единичный — было. В чистом виде
битовое хэширование не применяется из-за высокой вероятности коллизий
[1]. Возможные решения включают в себя:

\begin{enumerate}
\item Использование нескольких независимых хэш-функций. Каждое
  состояние имеет, таким образом, несколько индексов (\Code{{i1 = hash1(S),
    i2 = hash2(S), ... in = hashn(S)}}) и считается найденным в
  хэш-таблице только в том случае, если все биты \Code{{i1, i2, ... in}}
  установлены.

\item Использование традиционной хэш-таблицы, в которой вместо самих
  состояний хранятся их хэш-коды, полученные при помощи хэш-функции
  \Code{hash*(S)} большей разрядности (например, 64 бита). Функция \Code{hash*}
  должна быть независима от \Code{hash}, используемой для индексации в этой
  таблице [1].
\end{enumerate}

\chapter{Параллельная генерация состояний}
\label{sec:par-statespace}

\section{Алгоритм}
\label{sec:par-algo}

Возможны два варианта параллельной генерации состояний:

\begin{enumerate}
\item Распределенное хранилище состояний. Состояния генерирует только
  один узел, а для хранения используются все узлы. Каждое состояние
  имеет свой однозначно вычислимый номер узла. Преимуществом данного
  подхода является возможность по-прежнему использовать поиск в
  глубину, необходимый для поиска циклов. Недостаток заключается в
  том, что каждое новое состояние требует удаленного вызова (обращения
  к другому узлу) для проверки, было ли он уже достигнуто.

\item Распределенная генерация состояний. Каждый узел является
  одновременно хранилищем и генератором. Этот вариант предпочтителен,
  поскольку используется вычислительная мощность всех узлов и
  сокращается число удаленных вызовов за счет тех случаев, когда новое
  состояние принадлежит тому же самому узлу. Хотя каждый узел может
  выполнять с локальной точки зрения поиск в глубину, глобальный
  порядок достижения состояний нарушается, и поиск циклов становится
  затруднителен. В работах [2,3] было предложено несколько различных
  алгоритмов, совмещающих поиск в ширину с последующим нахождением
  циклов за счет определенной потери производительности. Зачастую
  верификация модели требует лишь проверки корректности конечных
  состояний и выполнения инвариантов, а в этом случае поиск циклов не
  требуется, что позволяет использовать в данном варианте обычный
  поиск в ширину.
\end{enumerate}

Параллельная версия алгоритма для второго случая выглядит следующим
образом:

\begin{CodeBlock}
Visited = []
Queue = []
if NodeId = 0:
    Queue += start_state
def ParStateSpaceBFS():
    while not empty(Queue):
        state <- Queue
        node = StateNode(state)
        if NodeId = node:
            if not state in Visited:
                Visited += state
                for each transition t from state:
                    next_state = next state after t
                    Queue <- next_state
        else:
            node.Queue <- state
ParStateSpaceBFS()
\end{CodeBlock}

\section{Распределение состояний между узлами}
\label{sec:state-partition}

В приведенном коде для определения номера узла, хранящего сообщения,
используется функция StateNode. Эта функция должна обладать следующими
характеристиками:

\begin{itemize}
\item она должна зависеть только от самого состояния, поскольку одно и
  то же состояние может генерироваться различными узлами в результате
  различных переходов;

\item она должна по возможности распределять состояния между узлами
  равномерно;

\item она должна обладать определенной локальностью — по возможности
  новые состояния должны принадлежать тому же узлу, что и исходное,
  для уменьшения числа удаленных вызовов.
\end{itemize}

Наиболее простым подходом является в качестве \textbf{StateNode} использовать
хэш-функцию от всего состояния. Это обеспечит первые 2 условия: если
выбрана подходящая хэш-функция, распределение будет достаточно
равномерным. Однако, третье условие при этом не соблюдается, поскольку
все новые состояния имеют равные шансы принадлежать любому узлу
независимо того, на каком узле они были сгенерированы.

Пусть число узлов — $N$, состояний — $S$, переходов между ними —
$T$. В случае равномерного распределения состояний между узлами
вероятность того, что следующее состояние будет принадлежать текущему
узлу равняется $\frac{1}{N}$. Следовательно, вероятность того, что
потребуется удаленный вызов, равна $1 - \frac{1}{N}$, а среднее число
удаленных вызовов в течение всей генерации составит $T \ldot (1 -
\frac{1}{N})$, что при больших значениях $N$ стремится с $T$. Как
показывают эксперименты в [4], столь частые пересылки состояний
негативно отражаются на производительности, поэтому необходимо найти
более удачное распределение состояний, которое бы удовлетворяло
условию локальности.

В [4] предлагается для распределения состояний по узлам хэшировать не
все состояние целиком, а лишь локальное состояние одного процесса. В
этом случае удаленный вызов будет происходить лишь при переходах,
изменяющих локальное состояние этого процесса.

Пусть $P$ — число процессов в модели, $k$ — среднее число процессов,
затрагиваемых переходом (состояние которых меняется при переходе). $k
> 1$, так как возможна (атомарная) передача сообщений между
процессами, при которой сообщение меняют одновременно 2 процесса. $k <
2$, так как взаимодействие трех или более процессов в языке Promela
нереализуемо.

Если предположить, что каждый процесс участвует примерно в равной доле
переходов, то для произвольного наперед заданного процесса вероятность
участия в данном переходе составит $\frac{k}{P}$. Если
\Code{StateNode} отображает множество локальных состояний процесса на
множество узлов равномерным образом, то, по аналогии с предыдущими
рассуждениями, вероятность удаленного вызова при изменении состояния
процесса составит $1 - \frac{1}{N}$. Количество удаленных вызовов во
всей модели, таким образом, равняется $\frac{k}{P} \ldot (1 -
\frac{1}{N})$ и с ростом $N$ стремится к $T \ldot \frac{k}{P}$. При
количестве процессов $P = 6-8$ и $k = 1.5$, т.е. когда половина переходов
приходится на взаимодействия процессов, получаем в $P/k = 4-5$ раз
меньше удаленных вызовов, чем при хэшировании состояния целиком.

\backmatter

\Conclusion

Замечательно выходит.

\begin{thebibliography}{99}
\bibitem{Pup99} Василий Пупкин. Latex для <<чайников>>.~--- М.: 2009~--- 50 c.
\end{thebibliography}

\end{document}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% End: 
