\chapter{Последовательная генерация состояний}
\label{sec:seq-statespace}

\section{Алгоритм построения}
\label{sec:seq-algo}

Процесс обычного (последовательного) построения пространства состояний
можно рассмотреть на примере упомянутого ранее верификатора SPIN.

Модель конечной системы на языке Promela описывается в виде ряда
взаимодействующих процессов, обменивающихся сообщениями через каналы
ограниченной емкости. Состояние системы представляет собой набор
значений глобальных переменных и локальных состояний каждого из
процессов. Состояние процесса включает в себя его <<счетчик инструкций>>
и набор локальных переменных. Множество переходов из текущего
состояния представляет собой объединение возможных переходов для
каждого процесса из его локального состояния.

Пример модели на на этом языке, описывающей семафор Дейкстры и 3
процесса, захватывающих его:

\begin{CodeBlock}
mtype { p, v };
chan sema = [0] of { mtype };
active proctype Dijkstra()
{      byte count = 1;
       do
       :: (count == 1) ->
               sema!p; count--
       :: (count == 0) ->
               sema?v; count++
       od
}
active [3] proctype user()
{       do
        :: enter: sema?p; /* enter critical section */
            crit: skip;   /* critical section */
                  sema!v; /* leave critical section */
        od
}
\end{CodeBlock}

Последовательный алгоритм построения пространства состояний,
используемый верификатором SPIN, можно представить следующим
псевдокодом:

\begin{CodeBlock}
Visited = []
def StateSpaceDFS(state):
    if not state in Visited:
        Visited += state
        for each transition t from state:
            next_state = next state after t
            StateSpaceDFS(next_state)
StateSpaceDFS(start)
\end{CodeBlock}

Последовательное построение пространства состояний с ростом размера
модели быстро становится невозможным из-за нехватки памяти для
хранения множества достигнутых состояний (\Code{Visited}). Можно предложить
два решения проблемы: использование оптимизаций, сокращающих расход
памяти, и параллельная генерация состояний с распределением хранимых
состояний между различными узлами вычислительной сети.

\section{Битовое хэширование состояний}
\label{sec:bit-hashing}

Одной из оптимизаций, позволяющей сократить расходуемый объем памяти,
является так называемое битовое хэширование состояний (\Term{bit-state
hashing}). Суть его заключается в том, что вместо традиционной
хэш-таблицы, с открытой индексацией или со списками, для хранения
состояний используется битовая таблица. Каждое состояние \Code{S}
представлено в ней битом с номером \Code{i = hash(S)}. Нулевой бит означает,
что состояние еще не было достигнуто, единичный — было. В чистом виде
битовое хэширование не применяется из-за высокой вероятности коллизий
[1]. Возможные решения включают в себя:

\begin{enumerate}
\item Использование нескольких независимых хэш-функций. Каждое
  состояние имеет, таким образом, несколько индексов (\Code{{i1 = hash1(S),
    i2 = hash2(S), ... in = hashn(S)}}) и считается найденным в
  хэш-таблице только в том случае, если все биты \Code{{i1, i2, ... in}}
  установлены.

\item Использование традиционной хэш-таблицы, в которой вместо самих
  состояний хранятся их хэш-коды, полученные при помощи хэш-функции
  \Code{hash*(S)} большей разрядности (например, 64 бита). Функция \Code{hash*}
  должна быть независима от \Code{hash}, используемой для индексации в этой
  таблице [1].
\end{enumerate}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
