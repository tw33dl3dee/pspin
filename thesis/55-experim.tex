\chapter{Проведение экспериментов}
\label{cha:experiments}

\section{Выбор факторов и их уровней}
\label{sec:experiment-strategy}

Основной целью являлось создание средства проверки свойств моделей, которое бы могло
проверять модели б\'{о}льшего размера, чем это позволяют существующие средства с
последовательной генерацией. Поэтому главным исследуемым фактором является принципиальная
возможность генерации пространства состояний моделей.

Проверка свойств модели может занимает длительное время. Поскольку на практике модель
редко бывает задана сразу без ошибок, процесс ее отладки и проверки может включать в себя
много прогонов, поэтому время является важным фактором. Необходимо убедиться, что время
генерации состояний модели растет линейно с ее размером и не является существенно худшим,
чем при проверке существующими средствами. Сравнение делается с ПО Spin, поскольку в
качестве способа описания модели используется поддерживаемый им язык Promela.

Было спроектировано и реализовано два различных способа распределения состояний по
узлам. Их сравнение включает в себя сравнение количества удаленных вызовов, степень
равномерности распределения и итоговое время работы.

\section{Средства для проведения эксперимента}
\label{sec:experiment-idef0}

Для экспериментов использовался кластер~МГТУ, состоящий из 102 вычислительных
узлов. Каждый узел имеет 4 процессора Intel\regsign Xeon\regsign~5120 с тактовой частотой
$1.86$~ГГц и 4 Гб оперативной памяти; узлы соединены 10-гигабитной шиной Infiniband. На
узлах установлена ОС RHEL~5.3 и библиотека Intel~MPI~3.1.

Разработанное средство свойств проверки моделей помимо результата проверки и контрпримера
выдает также детальную информацию о ходе работе: время выполнения/ожидания, количество
сохраненных состояний, выполненных переходов, удаленных вызовов, степень заполнения
хэш-таблицы и количество коллизий\etc Полученная информация обрабатывается набором
сценариев на языке \Code{Python} для выдачи в табличном формате. Графическое представление
полученных табличных данных строится при помощи системы построения графиков \Code{gnuplot}.

Функциональная схема проведения экспериментов показана на рис.~\ref{fig:exp-idef0}.

\begin{figure}[ht]
  \centering
  \includegraphics[width=1\textwidth]{../graphics/exp-idef0}
  \caption{Функциональная схема проведения экспериментов}
  \label{fig:exp-idef0}
\end{figure}

\section{Выбор исходных данных}
\label{sec:experiment-models}

В качестве моделей для экспериментов выбрано две модели, описанных в\cite{SPIN}: модель
обедающих философов \Code{Philo} и алгоритм выбора лидера \Code{Election}. Полный код
использованных моделей приведен в приложении[].

В модели \Code{Philo} все процессы одинаковы и не имеют переменных, кроме счетчика
инструкций, принимающего $24$ значения. Данная модель специально выбрана как неудачный
случай для спроектированного в разделе~\ref{sec:state-partition} распределения состояний
из-за отсутствия локальных переменных. $\Omega_i = 24$ в этом случае, поэтому при
использовании лишь $\rho = 1$ одного процесса для распределения количество узлов не может
превышать 24; при использовании 2 процессов можно ожидать большей равномерности
распределения.

Модель \Code{Election} также состоит из $P$ одинаковых процессов, каждый из которых имеет
6 локальных переменных и счетчик инструкций, принимающий 32 значения. Переменные могут
принимать $12 P (P-1)$ значений, поэтому $\Omega_i = 384\cdot P (P - 1)$. Это позволяет
ожидать лучшего распределения уже при $\rho = 1$.

\section{Зависимость количества состояний от времени}
\label{sec:space-time}

В данном эксперименте оценивается время генерации пространства состояний разработанным ПО
и существующим ПО Spin. Поскольку Spin реализует последовательную генерацию состояний, он
запускается лишь на одном узле. 

Запуск разработанного ПО производится на наборе от 8 до 80 узлов в двух режимах:
\begin{enumerate}
\item использование полного хэширование с коллизиями; в этом случае число узлов выбиралось
  так, чтобы средняя загрузка хэш-таблицы не превышала 70\%;
\item использование битового хэширования с $k = 3$ хэш-функциями; число узлов выбиралось
  таким, чтобы обеспечить ожидаемое покрытие (формула в
  разделе~\ref{sec:multi-bit-hashing}) не менее 99\%.
\end{enumerate}

На графике~\ref{fig:states-speed} по оси абсцисс показано количество состояний модели, по
оси ординат~--- время генерации.

\begin{figure}[ht]
  \centering
  \includegraphics[width=1\textwidth]{../data/plots/states-speed}
  \caption{Зависимость времени генерации от числа состояний}
  \label{fig:states-speed}
\end{figure}

При моделях с небольшим размером пространства состояний, до $10^7$, памяти одной машины
достаточно для хранения всего множесва посещенных состояний. В этом диапазоне время работы
ПО Spin и разработанного сравнимы. Модели с числом состояний $10^7-10^8$ уже невозможно
проверить последовательной генерацией, поэтому приведены данные лишь для
параллельной. 

Поскольку имевшееся в распоряжении количество узлов кластера ограничено (100, на практике
до 80), для проверки модели, имеющих $10^9$ и больше состояний, необходимо использовать
битовое хэширование с потерей состояний. Это позволяет сгенерировать до почти $10^{11}$
состояний, после чего ожидаемое покрытие становится меньше 99\% при использовании 80
узлов.

\section{Скорость генерации состояний}
\label{sec:stategen-speed}

Данный тест носит синтетический характер: сравнение скорости собственно генерации
состояний разработанного генератора со скоростью работы Spin. В данном тесте не
учитываются сетевые задержки, поэтому тест проводился в виде последовательной генерации
состояний на одной машине (процессор Intel\regsign Core\tmsign2 Duo E6850 3.00~ГГц, 2
Гбайт оперативной памяти).

Для эксперимента использовались две уже упомянутые модели, \Code{Philo} и \Code{Election},
а также модель алгоритма критической секции Петерсона~\cite{SPIN}. Результаты эксперимента
приведены в табл.~\ref{tab:stategen-speed}. Учитываются все сгенерированные состояния, в
том числе уже однажды посещенные.

\begin{table}[ht]
  \centering
  \caption{Сравнение скорости генерации состояний}
  \begin{tabular}{ccccc}
    \hline
    Модель & Число     & ПО Spin,   & Разработанное ПО, & Отношение \\
           & процессов & сост./сек &  сост./сек         & скоростей \\
    \hline
    \input{../data/inc/stategen-speed.tex}
    \hline
  \end{tabular}
  \label{tab:stategen-speed}
\end{table}

Из эксперимента видно, что скорость генерации состояний сравнима с таковой в ПО Spin, что
свидетельствует о хорошем качестве генерируемого кода.

\section{Сравнение распределения состояний}
\label{sec:experiment-partition-cmp}

В данном эксперименте сравниваются 3 схемы распределения состояний: хэшированием всего
состояния и хэшированием первых $\rho$ процессов при $\rho = 1$ и $\rho = 2$. Используются
модели \Code{Philo} с $P = 6$ и \Code{Election} с $P = 8$, запуск производится на 8 узлах.

На рис.~\ref{fig:state-partition1} и~\ref{fig:state-partition2} приведены результаты по
двум срезам: модели и схеме распределения. Сраниваются следующие четыре фактора:
\begin{enumerate}
\item доля переходов, приводящих к посылке сообщения другому узлу; усредняется по всем
  узлам;
\item неравномерность распределения состояний между узлами как отношение
  среднеквадратичного отклонения числа состояний к среднему значению по всем узлам;
\item время, которое узел проводит в ожидании приема сообщения (сетевые задержки); сюда
  также входит описанное в разделе~\ref{sec:async-mpi-queue} ожидание доставки сообщения,
  когда все исходящие буфера заняты; усредняется по всем узлам;
\item суммарное время выполнения (одно для всех узлов);
\end{enumerate}

\begin{figure}[p]
  \centering
  \includegraphics[width=2\textwidth]{../data/plots/state-partition1}
  \caption{Распределение состояний между узлами; срез по типу распределения}
  \label{fig:state-partition1}
\end{figure}

\begin{figure}[p]
  \centering
  \includegraphics[height=0.9\textheight]{../data/plots/state-partition2}
  \caption{Распределение состояний между узлами; срез по модели}
  \label{fig:state-partition2}
\end{figure}

При использовании хэша всего состояния (справа на рис.~\ref{fig:state-partition1})
неравномерность распределения достигает лишь 0.1\% в обоих случаях, однако число сообщений
близко к числу всех переходов (до 90\%), в результате чего, как и ожидалось, время
выполнения очень велико; большую часть времени узлы простаивают, ожидая состояний друг от
друга. 

При распределении по $\rho = 1$ процессу число удаленных вызовов составляет порядка
16--20\% от числа всех переходов, что находится в согласии с
формулой~(\ref{eq:nmsg-firstproc-hash}). Неравномерность распределения при этом для
\Code{Election} составляет 65\%, а для \Code{Philo}~--- 90\%, что подтверждает изначальное
предположение.

Распределение по $\rho = 2$ процессам представляет собой компромисс между временем и
равномерностью: для модели \Code{Philo} неравномерность, как и ожидается, по-прежнему
велика и составляет 30\%, для \Code{Election}~--- всего 10\%. Последнюю цифру можно
считать приемлемой, так как это означает, что трата памяти узла не превышает 10\% с
вероятностью $\alpha = \Phi^{-1}(1) = 83\%$. Число сообщений и время простоя при этом в 2
раза больше, чем в предыдущем случае, но в 2--3 раза меньше, чем при равномерном
распределении.

Следует отметить, что время простоя составляет б\'{о}льшую часть времени выполнения,
особенно при равномерном распределении, поэтому изначальное предположение о важности
выбора распределения для времени проверки свойств модели было верным.

\section{Анализ результатов}
\label{sec:experiment-analysis}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
