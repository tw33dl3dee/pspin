\chapter{Хранение состояний в памяти узлов}
\label{cha:par-state-store}

Каждый узел хранит множество посещенных состояний \Code{Visited}, текущую очередь
\Code{Queue} и хэш-таблицу для быстрого поиска состояний в \Code{Visited}. В зависимости
от того, какой из описанных в~\ref{sec:seq-statespace} тип хэширования выбран, состояния
хранятся в них по-разному.

В данной работе рассматриваются два подхода: полное хэширование с открытой адресацией и
битовое хэширование с произвольным (задаваемым) число хэш-функций.

\section{Полное хэширование}
\label{sec:fullhash-store}

При полном хэшировании хэш-таблица хранит указатели на состояния в \Code{Visited}. Сами
состояния хранятся при этом отдельно, это связано с тем, что их размер заранее не
определен и может меняться, тогда как записи в таблице должны быть фиксированного размера.

Выбор открытой адресации обснован тем, что хранить лишний указатель на каждое состояние
накладно для моделей, состояние кооторых имеет небольшой размер, особенно на 64-битных
архитектурах (см.~\ref{sec:state-hashing}). Как следствие, слишком высокое (выше 80--85\%)
заполнение хэш-таблиц при открытой адресации недопустимо. 

Может показаться, что результирующий расход на увеличение хэш-таблицы будет еще больше,
однако это не так. Если количество состояний, хранящихся на узле $i$, равно $S_i$, то
минимальный размер хэш-таблицы при закрытой адресации составляет $M_{closed} = S_i$
указателей, но при этом каждое состояние содержит дополнительный указатель, т.е. общее
число хранимых указателей $2 S_i$. При открытом хэшировании минимальный размер хэш-таблицы
$M_{open} = (1.2-1.3)S_i$, и никакие дополнительные указатели при этом не хранятся. В
результате расход памяти уменьшается на $(0.6-0.7)\cdot S_i\cdot PS$ байт, где $PS$~---
размер указателя ($8$ для 64-битной платформы).

Для того, чтобы избежать ненужного копирования, множество посещенных состояний
\Code{Visited} объединяется с \Code{Queue}. Новое состояние проверяется на вхождение в
хэш-таблицу сразу при генерации, и в случае отсутствия добавляется в \Code{Queue}. Таким
образом, все попадающие в \Code{Queue} состояния рано или поздно перейдут в
\Code{Visited}, поэтому они занимают один последовательный блок памяти, как это показано
на рис.~\ref{fig:fullstate}. Новые состояния добавляются в верхнюю часть \Code{Queue},
при этом указатель на начало свободной области сдвигается вверх. Выборка состояний из
\Code{Queue} делается с низу очереди, при этом указатель на ее начало сдвигается (и
состояние <<переносится>> в \Code{Visited}). Если свободная область памяти заканчивается,
алгоритм завершается с ошибкой.

\begin{figure}[ht]
  \centering
  \includegraphics[width=1\textwidth]{../graphics/fullstate}
  \caption{Хранение состояний при полном хэшировании}
  \label{fig:fullstate}
\end{figure}

\section{Битовое хэширование}
\label{sec:bithash-store}

При битовом хэшировании состояния после добавления в хэш-таблицу отбрасываются и
занимаемая ими память используется для хранения следующих состояний. Поэтому множество
\Code{Visited} как таковое отсутствует (оно представлено целиком в вид хэш-таблицы,
которая и занимает при этом почти весь доступный объем памяти). Сами состояния хранятся
лишь в очередь \Code{Queue}.

Новые состояния добавляются в верхнюю часть очереди, при этом указатель на начало
свободной области сдвигается вверх. Однако, в отличие от от~\ref{sec:fullhash-store},
выборка состояний также делается с верху \Code{Queue} (т.е. она работает, как
стек). Поэтому при выборке состояние наверху очереди копируется в отдельное место
(например, в конец свободной области, как показано на рис.~\ref{fig:bitstate}), а его
прежняя область памяти затирается следующим добавляемым состоянием.

Объем памяти, который необходимо отвести под \Code{Queue}, сильно зависит от модели: в
каких-то моделях очередь может достигать большой длины, в каких-то она практически не
растет.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.7\textwidth]{../graphics/bitstate}  
  \caption{Хранение состояний при битовом хэшировании}
  \label{fig:bitstate}
\end{figure}

\section{Выбор функции хэширования}
\label{sec:hashing-function}

При использовании полного хэширования состояний необходимо как минимум две независимые
хэш-функции: для вычисления индексов в хэш-таблице и для вычисления \Code{StateNode}. При
использовании битового хэширования с $h$ функциями необходимо $k + 1$ независимых
хэш-функций. Желательно объединить их в одну хэш-функцию, имеющую дополнительный параметр
(\Term{seed}).

Из требований к хэш-функции можно выделить следующие:
\begin{enumerate}
\item высокая равномерность распределения;
\item доступность (отсутствие ограничений, связанных с программными патентами);
\item скорость (согласно~\cite{LS99,BitHash1} существенная часть вычислений при генерации
  состояний тратится именно на поиск в хэш-таблице, в том числе на вычисление хэшей).
\end{enumerate}

На основе этих требований был выбран алгоритм под названием
\Code{MurmurHash}~\cite{Murmur}, созданный Остином Эпплби (Austin Appleby). Согласно
тестам, выполненным в~\cite{Murmur}, \Code{MurmurHash} обладает равной или превосходящей
другие алгоритмы равномерностью распределения на широком круге задач и высокой
скоростью. Код относится к public domain и доступен для 32-~и 64-битной платформ.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
