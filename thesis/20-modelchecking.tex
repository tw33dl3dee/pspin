\chapter{Задача проверки моделей}
\label{cha:model-checking}

При разработке сложных параллельных систем (систем, состоящих из нескольких асинхронно
работающих компонент) с высокой степенью надежности традиционных подходов к тестированию
вроде функционального и нагрузочного тестирования зачастую бывает
недостаточно. Приведенные способы обычно позволяет выявить лишь наиболее часто
встречающиеся ошибки. В некоторых случаях, например, если это программное обеспечение для
бортовых систем или управления ядерной реакцией, требуется полностью исключить
определенные классы ошибок~--- такие, как взаимоблокировки отдельных компонент системы,
\Term{гонки} (race condition) в параллельных алгоритмах и т.д.

Условно можно разделить ошибки в программных комплексах на 4 категории по 2 признакам, как
это показано в табл.~\ref{tab:error-classes}. Ошибки с высокой частотой возникнования
могут быть выявлены тестированием. Для ошибок высокой критичности, возникающих с малой
вероятностью, нужные иные способы поиска.

В случае, если проверяется не параллельный программный комплекс, а некий параллельный
алгоритм или протокол взаимодействия~--- например, новое расширение TCP для контроля
трафика~--- тестирование также неприменимо, поскольку тестировать нечего. В обоих случаях
необходимо использовать метод, называемый \Term{проверкой модели}.

\begin{table}[hb]
  \centering
  \begin{tabular}{|c|c|c|} \hline
    \textbf{Вероятность} & \multicolumn{2}{|c|}{\bf Степень критичности} \\ \cline{2-3}
    \textbf{возникновения} & Высокая & Низкая \\ \hline
    Высокая & Тестирование & Тестирование \\  \hline
    Низкая  & \textbf{Проверка модели} &  \\  \hline
  \end{tabular}  \caption{Классы ошибок в программных комплексах}
  \label{tab:error-classes}
\end{table}

Проверка моделей~--- это автоматический формальный подход (т.е. проверяется не само ПО, а
некоторая его формальная модель). Для формализации представлений о моделируемом алгоритме
или протоколе обычно используется разновидность графа состояний, называемая \Term{моделью
  Крипке}~\cite{Clarke}, рассматриваемая далее.

\section{Представление компонент параллельных систем}
\label{sec:mealey-formalization}

Поведение отдельных компонент параллельной системы можно представить в виде автоматов
Мили~\cite{Velder}. В автомате Мили каждая дуга помечена входной и выходной
последовательностями. Состояниями автомата являются отдельные этапы выполнения компонента,
входные последовательности у переходов между двумя состояниями~--- события, которых он
ожидает (в том числе пустое событие \Code{True}, если между двумя этапами ожидания нет),
а в качестве выходной последовательсти~--- атомарные действия, выполняемые компонентом.

В качестве примера рассмотрим поведение философа из задачи об обедающих
философах~\cite{Dijkstra}, при условии, что философ всегда берет сначала левую вилку, а
затем правую. Начальным состоянием философа является <<размышление>>. Из него, если левая
вилка свободна, он может перейти в состояние <<держит 1 вилку>>, выполняя при этом
атомарное действие <<взять вилку>>.\footnote{Вообще говоря, у философа есть состояние
  <<голоден>>, в которое он спонтанно переходит из <<размышляет>>, однако мы будем для
  простоты считать, что, размышляя, философ уже голоден и может спонтанно взять вилку в
  любой момент, если она будет свободна.} Атомарным оно является в том смысле, что другой
философ не может взять ту же вилку, если ее уже <<начал брать>> данный философ. Важно
отметить, что переход автомата из состояния в состояние происходит не обязательно в тот
самый момент времени, как вилка освобождается, т.е. поведение компонент параллельной
системы во времени не является детерминированным~--- это обусловлено различными задержками,
разной скоростью их работы, псевдопараллельным выполнением\etc.

Затем, при выполнении условия <<правая вилка свободна>>, философ совершает действие
<<взять правую вилку>>, после которого оказывется в состоянии <<ест>>. Какие-то конкретные
ограничений на то, сколько философ должен есть, в нашем примере отсутсвуют, поэтому из
состояния <<ест>> философ в любой момент спонтанно (т.е. по пустому событию \Code{True})
переходит в начальное состояние <<размышляет>>, выполняя действие <<положить обе
вилки>>. Автомат, описывающий данное поведение философа, приведен на рис.~\ref{fig:philo-mealey}.

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.65\textwidth]{../graphics/philo-mealey}
  \caption{Поведение философа в виде автомата Мили}
  \label{fig:philo-mealey}
\end{figure}

\section{Представление параллельных систем в целом}
\label{sec:kripke-formalization}

В \ref{sec:mealey-formalization} описано, как представить поведение отдельных
компонент системы. Систему целиком можно представить, как объединение автоматов Мили,
описывающих каждую из ее компонент. Например, систему из двух обедающих философов можно
представить в виде двух одинаковых автоматов Мили (отличающихся тем, что понятия
<<правой>> и <<левой>> вилки у них разные). Однако, такое описание тяжело использовать для
проверки каких-либо утверждений о системе. Для этого можно использовать другой способ ее
формального представления~--- упомянутую выше модель Крипке.

Моделью Крипке $M$ над множеством атомарных высказываний $AP$ называют четверку $M=(S,
S_0, R, L)$, где:
\begin{enumerate}
\item $S$~--- конечное множество состояний;
\item $S_0 \subseteq S$~--- множество начальных состояний;
\item $R \subseteq S \times S$~--- отношение переходов, которые обязано быть тотальным,
  т.е. для каждого состояния $s \in S$ должно существовать такое состояние $s' \in S$, что
  имеет место $R(s, s')$;
\item $L: S \rightarrow 2^{AP}$~--- функция, которая помечает каждое состояние множеством
  атомарных высказываний, истинных в этом состоянии.
\end{enumerate}

\Term{Путь} в модели $M$ из состояния $s$~--- это бесконечная последовательность состояний
$\pi = s_0s_1s_2 \ldots$ что $s_0 = s$ и для всех $i \geq 0$ выполняется $R(s_i,
s_{i+1})$.

Рассмотрим множество $V = {v_1, v_2 \ldots}$ переменных системы, входящих в проверяемую
модель. Будем считать, что они принимают значения из конечного множества $D$, называемого
\Term{доменом} интерпретации. Для системы из двух философов множество $V$ будет включать в
себя состояние двух вилок (<<свободна>>/<<занята>>) и состояния обоих философов (из
множества состояний автомата на рис.~\ref{fig:philo-mealey}). 

Состоянием системы будем называть набор значений, сопоставляемых всем переменным из $V$,
т.е. отображение $s: V \rightarrow D$. Примером состояния для системы двух философов может
быть <<первая вилка занята, вторая свободна, первый философ взял 1 вилку, второй
размышляет>>. Для краткости будем это записывать как $\{B: (1, 0); \Phi: (1, P)\}$, где $B$
-- двойка переменных, описывающих состояние вилок ($0$~--- свободна, $1$~--- занята), а
$\Phi$~--- двойка переменных, описывающих состояние философов ($P$~--- размышляет, $1$~---
взял одну вилку, $E$~--- ест).

Пусть у нас есть два состояния, $V_1$ и $V_2$. Если в $V_1$ имеется компонент, из текущего
состояния которого выходит дуга с выполненным условием (входной последовательностью) и
действием (выходной последовательностью), в результате выполнения которого система будет
находиться в состоянии $V_2$, будем говорить, что состояния $V_1$ и $V_2$ связаны
отношением перехода: $(V_1, V_2) \in R$.

Например, в рассмотренном выше состоянии первый философ находится в состоянии
<<держит 1 вилку>>, из которого ведет дуга в состояние <<ест>>, условие которой~---
<<правая вилка свободна>>~--- в этом состоянии выполнена (для первого философа <<правой>>
является вторая вилка). При переходе по этой дуге система прийдет в состояние $\{B: (1, 1);
\Phi: (E, P)\}$.

В случае, если нет такого состояния $V_2$, для которого бы выполнялось $R(V_1, V_2)$,
будем считать, $R(V_1, V_1)$, т.е. <<тупиковое>> состояние $V_1$ связано отношение
перехода само с собой.

Определив таким образом состояние и отношение перехода, мы можем построить модель Крипке,
$M = (S, S_0, R, L)$, формализующую данную систему.
\begin{enumerate}
\item Множество состояний $S$ есть множество всех наборов значений переменных в $V$.
\item Множество начальных состояний $S_0$ состоит из одного состояния $s_0$, отвечающего
  начальным состояниям всех автоматов и начальным значениям переменных системы.
\item Отношение перехода $R$ между состояниями определено выше.
\item Функция разметки $L: S \rightarrow 2^{AP}$ ставит каждому состоянию $s$ в
  соответствие набор утверждений вида $v_i = d_i$, где $d_i \in D$~--- значение переменной
  $v_i$ в данном состоянии.
\end{enumerate}

Модель Крипке, получаемая таким образом для системы двух философов, показана на
рис.~\ref{fig:philo2-kripke}. Следует отметить, что есть также подмножество $S$ состояний,
недостижимых из $s_0$, например, $\{B: (0, 0); \Phi: (E, E)\}$ (оба вилки свободны, но
философы при этом едят). Такие состояния на рисунке не показаны для экономии места и в
дальнейшем нас интересовать не будут.

\begin{figure}[ht]
  \centering
  \includegraphics[width=1.0\textwidth]{../graphics/philo-kripke}
  \caption{Модель Крипке для системы из двух философов}
  \label{fig:philo2-kripke}
\end{figure}

\section{Проверка утверждений}
\label{sec:kripke-verification}

Полученная модель Крипке может использоваться для проверки относительно отсутствия тех или
иных ошибок в системе. В результате получается либо доказательство корректности системы
(она удовлетворяет всем требованиям), либо опровержение и контрпример~--- путь в модели
Крипке, на котором какое-то из утверждений не выполняется. Данный процесс представлен на
рис.~\ref{fig:idef0-verification}.

\begin{figure}[htb]
  \centering
  \includegraphics[width=1.0\textwidth]{../graphics/idef0-verification}
  \caption{Процесс проверки модели}
  \label{fig:idef0-verification}
\end{figure}

Проверяемые утверждения можно поделить на две категории.
\begin{enumerate}
\item Условия <<надежности>> (\Term{safety})~--- утверждения, что <<не случится ничего
  плохого>>. Примером может служить утверждение <<философы не войдут в состояние
  взаимоблокировки>>. Данное условие нарушается в состоянии, показанном на
  рис.~\ref{fig:philo2-kripke} другим цветом: в нем оба философа взяли по одной вилке и
  ждут доступности следующей, войдя, таким образом, во взаимоблокировку. Обычно такие
  условия сводятся к утверждению, что ни в одном из путей $\pi$ в модели $M$ в
  определенных (или всех) состояниях не будет встречаться недопустимая комбинация значений
  переменных системы. В дальнейшем в данной работе будет рассматриваться только эта
  категория утверждений.
\item Условия <<живости>> (\Term{liveness})~--- утверждения, что <<случится что-то
  хорошее>>. Пример: <<каждый философ бесконечно много раз пройдет через состояние приема
  пищи>> (т.е. ни один философ не будет в состоянии вечного голодания). Этот класс
  утверждений гораздо сложнее проверить, поскольку они не сводятся к недопустимым
  значениям переменных отдельного состояния, а затрагивают проверку путей модели $M$
  целиком: вышеприведенное утверждение, например, сводится к тому, что каждый путь $\pi$
  из начального состояния $s_0$ содержит в себе цикл $s_is_{i+1}\ldots s_js_i\ldots$, где
  среди $s_i\ldots s_j$ содержатся состояния $\{B: (1, 1); \Phi: (E, P)\}$ и $\{B: (1, 1];
  \Phi: P, E)\}$.
\end{enumerate}

Многие условия <<надежности>> можно формализовать при помощи функции $U: S \rightarrow
2^{AP}$, ставящей в соответствие каждому состоянию $s$ набор утверждений из $AP$ вида $v_i
= d_i, d_i \in D$, которые должны в нем выполняться. Если $\forall s \in S:\forall u \in
U(s):u \equiv True$, то модель удовлетворяет условиям. В противном случае, если имеется
такое $s_e \in S$, что $\exists u \in U(s_e): u \equiv False$, система некорректна и
контпримером является, в зависимости от нужд разработчика, само состояние $s_e$ или любой
путь $\pi_e$, содержащий $s_e$.

Некоторые условия <<надежности>> формализуются как требование, что для каждого состояния
$s$ из определенного подмножества $S_L \subset S$ должно существовать как минимум одно не
совпадающее с ним состояние $s'$, связанное с $s$ отношением перехода. В частности,
приведенный выше пример <<философы не войдут в состояние взаимоблокировки>> соответствует
случаю $S_L = S$.

Для формулировки условий <<живости>> есть ряд формальных языков, называемых временными
логиками. Наиболее часто из них используется \Term{логика линейного времени} (LTL, Linear
Time Logic) и \Term{логика ветвящегося времени} (CTL, Computation Tree
Logic)~\cite{Clarke}~\cite{Velder}, однако их рассмотрение выходит за рамки данной
работы.

На практике все условия <<живости>>, выражаемые при помощи LTL, можно переформулировать
так, что для некоторой модифицированной модели $M'$ они будут иметь вид <<на любом пути
$\pi$ имеется цикл, включающий в себя некоторое данное состояние $s'$>>. Например, если в
нашей системе из философов мы добавим двойку переменных $(a_1, a_2)$ <<первый (второй)
философ прошел через состояние приема пищи>>, изначально равные $0$, и добавим к двум
автоматам еще один, из двух состояний <<не все философы поели>> и <<все философы поели>>,
с условием перехода между ними $a_1 = 1 \wedge a_2 = 1$, то для проверки изначального
условия на новой модели достаточно потребовать вхождения в каждый путь $\pi$ цикла,
содержащего хотя бы одно состояние $s$, где последний автомат пребывает во втором своем
состоянии.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
