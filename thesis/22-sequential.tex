\chapter{Последовательная генерация состояний}
\label{sec:seq-statespace}

\section{Алгоритм генерации}
\label{sec:seq-algo}

Для построения пространства состояний верификатор SPIN использует последовательный поиск в
глубину, который можно представить следующим псевдокодом:

\begin{CodeBlock}
Visited = []
def StateSpaceDFS(state):
    if not state in Visited:
        Visited += state
        for each state' in Next(state):
            StateSpaceDFS(state')
StateSpaceDFS(start)
\end{CodeBlock}

Для получения $Next(s)$ вычисляются условия выполнимости текущих инструкций всех
процессов, присутствующих в $s$ (отсюда мы получаем множество незаблокированных процессов
$P_{ready}(s)$), после чего для каждого процесса $P$ из $P_{ready}(s)$ генерируется новое
состояние, получающееся в результате выполнения его текущей инструкции (номер которой
хранится в $IP_P$). Это можно представить в виде псевдокода следующим образом:

\begin{CodeBlock}
def Next(state):
    Next = []
    for each process in state:
        if Executable(process):
            state' = Copy(state)
            Step(state', process)
            Next += state'
\end{CodeBlock}

Здесь \Code{Executable} -- функция проверки выполнимости текущей инструкции процесса, а
\Code{Step} -- функция трансформации состояния при выполнении текущей инструкции
выбранного процесса.

\section{Хранение посещенных состояний}
\label{sec:state-hashing}

При генерации каждого состояния делается проверка, было ли оно уже посещено ранее
(т.е. находится в множестве \Code{Visited}) и добавление в этом множество в противном
случае. Для эффективного поиска состояния \Code{Visited} представляется в виде
хэш-таблицы.

По мере роста степени загрузки хэш-таблицы с большой вероятностью возникают коллизии; в
соответствии с парадоксом <<дней рождения>>, если в таблице на миллион элементов хранится
2500 ключей (т.е. степень заполненности составляет лишь 0.0025\%), вероятность совпадения
хэш-кодов хотя бы двух из них составляет 95\%, поэтому необходим алгоритм разрешения
коллизий.

\paragraph{Закрытая адресация}
\label{sec:closed-addressing}

При <<закрытой адресации>> (хэш-таблице со списками), показанной на рис.!!!рисунок!!! слева,
каждый элемент хэш-таблицы представляет собой список всех состояний, хэш-коды которых
совпадают и приходятся на этот элемент. При поиске состояния $s$ все состояния в списке
сравниваются (побайтово) с $s$, пока не будет обнаружено совпадение.

Производительность поиска в хэш-таблице с закрытой адресацией падает линейно с ростом ее
заполненности (отношения количества хранимых состояний к количесту ячеек в таблице). !!!ссылка?!!!

\paragraph{Открытая адресация с линейными пробами}
\label{sec:open-linear-probing}

В этом случае каждый элемент хранит ровно одно состояние (см. рис!!!рис!!! справа). При
поиске или сохранении состояния, если элемент $i = hash(s)$ занят другим состоянием (не
совпадающим с $s$), проверяются элементы с номерами $i + a, i + 2 \cdot a, i + 3 \cdot a,
\ldots$ до тех пор, пока не будет найдено нужное состояние либо не будет обнаружена
свободная ячейка (это означает, что $s$ отсутствует в хэш-таблице). Число $a$ должно быть
взаимно просто с размером хэш-таблица -- это позволяет гарантировать, что при полностью
заполненной хэш-таблице каждый элемент будет проверен хотя бы один раз.

При открытой адресации не требуется дополнительная память на хранение указателей в списке,
однако хранить в ней больше состояний, чем позволяет размер таблицы, невозможно (в то
время как при закрытой адресации размер таблицы не является ограничением). Кроме того,
когда степень заполненности таблицы превышает 80\%, производительность поиска начинает
резко падает, уменьшаясь на порядок при заполненности в 90\%.

\paragraph{Открытая адресация с квадратичными пробами}
\label{sec:open-quadratic-probing}

\paragraph{Двойное хэширование}
\label{sec:open-double-hashing}

\section{Проблема роста числа состояний}
\label{sec:state-explosion}

Последовательное построение пространства состояний $S$ с ростом размера модели
быстро становится невозможным из-за нехватки памяти для хранения множества
достигнутых состояний (\Code{Visited}). В табл. \ref{tab:models-statecount}
приведены данные для двух моделей: модели задачи об обедающих философов из
\ref{sec:promela} и более приближенной к реальным задачам модели RIP-протокола
на 4 сетевых маршрутизаторах.

\begin{table}
  \centering
  \begin{tabular}{|r|l|l|}
    \hline
    Модель                  & Состояний         & Переходов       \\
    \hline
    Философы (5)            & $2.8 \cdot 10^4$  & $4.2 \cdot 10^4$ \\
    Философы (7)            & $3.6 \cdot 10^5$  & $6.0 \cdot 10^5$ \\
    RIP (4 маршрутизатора)  & $1.6 \cdot 10^8$  & $4.8 \cdot 10^9$ \\
    \hline
  \end{tabular}
  \caption{Количество состояний и переходов в различных моделях}
\label{tab:models-statecount}
\end{table}

Из табл. \ref{tab:models-statecount} видно, что для реальных моделей традиционный подход
становится проблематичен: к примеру, модель RIP-протокола с 5-ю маршрутизаторами потребует
уже более 100 Гб оперативной памяти для хранения пространства состояний.

Существует ряд подходов, решающих данную проблему. Среди них можно выделить:

\begin{itemize}
\item методы оптимизации, уменьшающие количество генерируемых и хранимых состояний;
\item методы оптимизации, уменьшающие расход памяти на хранение пространства состояний;
\end{itemize}

Далее в \ref{sec:bit-hashing}-~\ref{sec:state-compression} описан ряд таких методов,
используемых верификатором SPIN.

\section{Сокращение частных порядков}
\label{sec:partial-order-reduction}

Сокращение частных порядков (\Term{partial order reduction}) \cite{POD} относится к первой
группе оптимизацих количество генерируемых состояний. Данный метод использует тот факт,
что зачастую порядок выполнения двух переходов в различных процессах не оказывает влияния
на результат верификации.

Пример показан на рис. \ref{fig:partial-order-reduction} слева:
допустим, нас интересует выполнение свойства $p$ в каждом из состояний
системы. $\alpha$ и $\beta$ -- два перехода различных процессов
$P_{\alpha}$ и $P_{\beta}$, которые оба возможны в состоянии $s_0$
(т.е. $P_{\alpha}$ и $P_{\beta}$ не заблокированы). При этом переход
$\beta$ нарушит свойство $p$. В том случае, если выполнение свойства
$p$ не зависит от перехода $\alpha$, порядок выполнения этих двух
переходов не важен, следовательно, генерацию состояния $s_2$ можно
предотвратить (на рис. \ref{fig:partial-order-reduction} справа).

% \begin{figure}[ht]
%   \begin{array}{p{0.4\textwidth}p{0.2\textwidth}p{0.2\textwidth}}
%   \begin{tikzpicture}[->,>=stealth',auto,node distance=4cm,semithick]
%     \tikzstyle{every state}=[fill=none,draw=black,text=black]
%     \node[state]     (A)                    {$s_0:~~p~$};
%     \node[state]     (B) [below right of=A] {$s_1:~~p~$};
%     \node[state]     (C) [below left  of=A] {$s_2:~\neg p$};
%     \node[state]     (D) [below right of=C] {$s_3:~\neg p$};
    
%     \path (A) edge node {$\alpha$} (B)
%               edge node {$\beta$}  (C)
%           (B) edge node {$\beta$}  (D)
%           (C) edge node {$\alpha$} (D);
%   \end{tikzpicture}
%   & 
%   &
%   \begin{tikzpicture}[->,>=stealth',auto,node distance=4cm,semithick]
%     \tikzstyle{every state}=[fill=none,draw=black,text=black]
%     \node[state]          (A)                    {$s_0:~p~$};
%     \node[state]          (B) [below right of=A] {$s_1:~p~$};
%     \node[state]          (D) [below left  of=B] {$s_3:~\neg p$};
    
%     \path (A) edge node {$\alpha$} (B)
%           (B) edge node {$\beta$}  (D);
%   \end{tikzpicture}
%   \end{array}
%   \caption{Демонстрация сокращения частных порядков}
%   \label{fig:partial-order-reduction}
% \end{figure}

Сокращение частных порядков возможно далеко не для любых пар
переходов, допустимых в данном состоянии:

\begin{itemize}
\item переходы не должны влиять на выпонимость друг друга
\item (коммутативность) оба перехода должны приводить к одному и тому же состоянию
  вне зависимости от порядка выполнения: $Next(Next(s_0)) = \{ s_3 \}$
\end{itemize}

В случае, если два процесса обращаются к глобальным переменным и/или
используют каналы для взаимодействия, множество переходов, для которых
допустимо сокращение частных порядков, существенно уменьшается. Кроме
того, проверка на наличие циклов делает СЧП невозможным. Однако, в тех
случаях, когда это допустимо, верификатор SPIN применяет метод СЧП для
уменьшения пространства состояний.

% http://tele.informatik.uni-freiburg.de/Teaching/ss02/dres/dres.part8.pdf

\section{Битовое хэширование состояний}
\label{sec:bit-hashing}

При битовом хэширование состояний (\Term{bit-state hashing}) вместо традиционной
хэш-таблицы для хранения состояний используется битовая таблица. Каждое состояние \Code{S}
представлено в ней битом с номером \Code{i = hash(S)}. Нулевой бит означает, что состояние
еще не было достигнуто, единичный — было.

!!! более подробная информация о коллизиях !!!

В чистом виде битовое хэширование не применяется из-за высокой
вероятности коллизий~\cite{BitHash1}:
\begin{equation}
  \label{eq:bithash-single-coll}
  P_1 = 1 - \frac{2^m}{N},
\end{equation}
где $m$ -- число бит, отводимых под хэш ($2^m$ -- количество бит в
хэш-таблице, т.е. не может превышать доступный нам объем памяти), а
$N$ -- число состояний. При больших $N >> M$ (а именно этот случай нас
интересует) $P_1 \approx 1$, т.е. коллизии почти наверняка возникнут.

Возможные решения включают в себя:

\begin{enumerate}
\item Использование нескольких независимых хэш-функций. Каждое
  состояние имеет, таким образом, несколько индексов (\Code{{i1 =
      hash1(S), i2 = hash2(S), ... in = hashn(S)}}) и считается
  найденным в хэш-таблице только в том случае, если все биты
  \Code{{i1, i2, ... in}} установлены. Вероятность возникновения
  коллизий, согласно~\cite{BitHash1}, в этом случае составляет
  \begin{equation}
    \label{eq:bithash-multi-coll}
    P_h = \frac{(2 h)^h}{h+1} (P_1)^h,
  \end{equation}
  что уже при $h = 2$ дает приемлемый результат. Верификатор SPIN по
  умолчанию использует 3 хэш-функции при активированном битовом
  хэшировании.

\item Использование традиционной хэш-таблицы, в которой вместо самих
  состояний хранятся их хэш-коды, полученные при помощи хэш-функции
  \Code{hash*(S)} большей разрядности (например, 64 бита). Функция \Code{hash*}
  должна быть независима от \Code{hash}, используемой для индексации в этой
  таблице \cite{BitHash1}. Данный подход применим, если исходное
  состояние имеет куда больший, чем 64 бита, размер, и объем памяти
  достаточен, чтобы хранить целиком хэш-таблицу, содержащую 64-битные
  хэши (т.е. $2^m > 64 N$). При $2^m < 100 N$ эффектиность подхода в
  сравнении с использованием независимых хэш-функций резко падает.
\end{enumerate}

\section{Сжатие состояний}
\label{sec:state-compression}

% http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.308
% http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.38.308&rep=rep1&type=pdf

Альтернативным способом, позволяющим уменьшить требуемый объем памяти ценой уменьшения
скорости генерации является сжатие хранимых состояний.

Можно предложить следующие способы сжатия состояний:

\begin{enumerate}
\item Сжатие при помощи кодов Хаффмана. Согласно исследованию из
  \cite{StateCompr}, в ходе которого было рассмотрен ряд моделей из
  реальных задач, в состояниях преобладают байты с малыми значениями,
  т.е. распределение значений байт в состояниях неравномерно; это
  делает коды Хаффмана хорошо применимыми. Недостатком кодов Хаффмана
  является существенное замедление работы (до 200\%).

\item <<Рекурсивная индексация>> состояний использует тот факт, что
  состояние $s$ включает в себя набор состояний отдельных процессов
  $s_{P_0}, s_{P_1}, ... s_{P_N}$; поскольку размер пространства состояний
  отдельно взятого процесса гораздо меньше, чем для всей системы,
  можно хранить локальные состояния процессов в отдельной
  хэш-таблице. При этом в глобальном состоянии по-прежнему хранятся
  значения глобальных переменных и содержимое каналов; все локальные
  состояния выносятся во вторичную хэш-таблицу, а их индексы хранятся
  в глобальном состоянии вместо них самих. Согласно \cite{StateCompr},
  выгоднее использовать одну вторичную хэш-таблицу вместо отдельных
  таблиц для каждого типа процессов (proctype). Недостатком данного
  подхода является необходимость заранее (на этапе генерации кода или
  при его инициализации) выбирать, сколько бит в состоянии отводить
  под индексы в хэш-таблицу локальных состояний (если впоследствии
  окажется, что размер вторичной таблицы недостаточен для хранения
  всех состояний, ее увеличение будет невозможно, так как потребовало
  бы пересчета всех уже сгенерированных состояний).
\end{enumerate}

В \cite{StateCompr} предлагается еще ряд методов сжатия, выгодных для
частных случаев задач, однако в рамках данной работы они не
рассматриваются. 

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
