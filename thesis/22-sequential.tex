\chapter{Последовательная генерация состояний}
\label{sec:seq-statespace}

\section{Алгоритм генерации}
\label{sec:seq-algo}

Для построения пространства состояний верификатор SPIN использует последовательный поиск в
глубину, который можно представить следующим псевдокодом:

\begin{CodeBlock}
Visited = []
def StateSpaceDFS(state):
    if not state in Visited:
        Visited += state
        for each state' in Next(state):
            StateSpaceDFS(state')
StateSpaceDFS(start)
\end{CodeBlock}

Для получения $Next(s)$ вычисляются условия выполнимости текущих инструкций всех
процессов, присутствующих в $s$ (отсюда мы получаем множество незаблокированных процессов
$P_{ready}(s)$), после чего для каждого процесса $P$ из $P_{ready}(s)$ генерируется новое
состояние, получающееся в результате выполнения его текущей инструкции (номер которой
хранится в $IP_P$). Это можно представить в виде псевдокода следующим образом:

\begin{CodeBlock}
def Next(state):
    Next = []
    for each process in state:
        if Executable(process):
            state' = Copy(state)
            Step(state', process)
            Next += state'
\end{CodeBlock}

Здесь \Code{Executable}~--- функция проверки выполнимости текущей инструкции процесса, а
\Code{Step}~--- функция трансформации состояния при выполнении текущей инструкции
выбранного процесса.

\section{Хранение посещенных состояний}
\label{sec:state-hashing}

При генерации каждого состояния делается проверка, было ли оно уже посещено ранее
(т.е. находится в множестве \Code{Visited}) и добавление в этом множество в противном
случае. Для эффективного поиска состояния \Code{Visited} представляется в виде
хэш-таблицы.

По мере роста степени загрузки хэш-таблицы с большой вероятностью возникают коллизии; в
соответствии с парадоксом <<дней рождения>>, если в таблице на миллион элементов хранится
2500 ключей (т.е. степень заполненности составляет лишь 0.0025\%), вероятность совпадения
хэш-кодов хотя бы двух из них составляет 95\%, поэтому необходим алгоритм разрешения
коллизий.

\paragraph{Закрытая адресация}
\label{sec:closed-addressing}

При <<закрытой адресации>> (хэш-таблице со списками), показанной на
рис. \ref{fig:hash-addressing} слева, каждый элемент хэш-таблицы представляет собой список
всех состояний, хэш-коды которых совпадают и приходятся на этот элемент. При поиске
состояния $s$ все состояния в списке сравниваются (побайтово) с $s$, пока не будет
обнаружено совпадение.

При размере таблицы $N$ и количестве записей в ней $M$, вероятность коллизии при каждом
обращении составляет $\frac{M}{N}$ (т.е. растет линейно с $M$). Поскольку длина списка
состояний в каждой ячейке в среднем не превосходит 2 даже при заполненности таблицы
(отношении количества хранимых состояний к количесту ячеек в таблице), близкой к 1, время
поиска в хэш-таблице с закрытой адресацией растет линейно с ростом ее
заполненности.~\cite{CDataStructures}.

\paragraph{Открытая адресация с линейными пробами}
\label{sec:open-linear-probing}

В этом случае каждый элемент хранит ровно одно состояние
(см. рис. \ref{fig:hash-addressing} справа). При поиске или сохранении состояния, если
элемент $i = hash(s)$ занят другим состоянием (не совпадающим с $s$), проверяются элементы
с номерами $i + a, i + 2 \cdot a, i + 3 \cdot a, \ldots$ до тех пор, пока не будет найдено
нужное состояние либо не будет обнаружена свободная ячейка (это означает, что $s$
отсутствует в хэш-таблице). Число $a$ должно быть взаимно просто с размером
хэш-таблица~--- это позволяет гарантировать, что при полностью заполненной хэш-таблице
каждый элемент будет проверен хотя бы один раз.

Недостаток этого алгоритма в том, что элементы имеют тенденцию <<скапливаться>> в
определенных областях, поскольку коллизия в одной ячейке сразу повышает вероятность
коллизии в соседней, коллизия в ней приводит к коллизии в следующей\etc

\begin{figure}[ht]
  \centering
  \begin{tabular}{cc}
    \includegraphics{../graphics/hash-closed}
    &
    \includegraphics{../graphics/hash-open}
  \end{tabular}
  \caption{Различные схемы адресации в хэш-таблице}
  \label{fig:hash-addressing}
\end{figure}

\paragraph{Открытая адресация с квадратичными пробами}
\label{sec:open-quadratic-probing}

Для решение проблемы предыдущего метода предлагается иная последовательность проб: при
коллизии элемента в ячейке $i$ проверяются ячейки с номерами $i + a + b, i + 4 \cdot a + 2
\cdot b, i + 9 \cdot a + 3\cdot b, \ldots$. Эти номера составляют квадратичную прогрессию,
отсюда и название. Преимуществом квадратичных проб над линейными является значительно
меньшая кластеризация коллизий при сохранении свойства локальности: просматриваемые при
поиске/вставке первые 3-4 состояний находятся достаточно близко друг к другу, чтобы
попадать в одну строку кэша.

\paragraph{Двойное хэширование}
\label{sec:open-double-hashing}

Радикальным подходом к устранению кластеризации коллизий является использование вторичной
функции хэширования, $hash'$. В случае коллизии просматриваются состояния $i + hash'(a), i
+ 2\cdot hash'(a), \ldots$. Однако, данный подход полностью лишен свойства локальности (в
случае коллизии следующее же проверяемое состояние уже выходит за пределы строки кэша
с только что выбранным), поэтому используется реже.

Общей проблемой всех методов открытой адресации заключается в том, что хранить в ней
больше состояний, чем позволяет размер таблицы, невозможно (в то время как при закрытой
адресации размер таблицы не является ограничением). Более того, когда степень
заполненности таблицы превышает 80\%, производительность поиска начинает резко падать,
уменьшаясь на порядок при заполненности в 90\%. Это связано с тем, что средняя длина
цепочки просматриваемых при коллизии состояний растет линейно вместе с заполненностью
таблицы $\frac{M}{N}$, а не остается константой, как при закрытой адресации.

Преимущество открытой адресации в том, что нет необходимости хранить списки состояний,
следовательно, расход памяти меньше. Особенно это важно для моделей, состояние занимает
небольшой объем памяти (порядка 20--30 байт), потому что в этом случае на 64-битной
архитектуре экономия будет составлять 25--40\%. В то же время для моделей с состоянием
большого объема открытая адресация дает незначительное преимущество, и при высокой
заполненности хэш-таблицы использование закрытой адресации предпочитетельно.

\section{Проблема роста числа состояний}
\label{sec:state-explosion}

Последовательное построение пространства состояний $S$ с ростом размера модели
быстро становится невозможным из-за нехватки памяти для хранения множества
достигнутых состояний (\Code{Visited}). В табл. \ref{tab:models-statecount}
приведены данные для двух моделей: модели задачи об обедающих философов из
\ref{sec:promela} и более приближенной к реальным задачам модели RIP-протокола
на 4 сетевых маршрутизаторах.~\cite{RipOnSpin}

\begin{table}
  \centering
  \begin{tabular}{|r|l|l|}
    \hline
    Модель                  & Состояний         & Переходов       \\
    \hline
    Философы (5)            & $2.8 \cdot 10^4$  & $4.2 \cdot 10^4$ \\
    Философы (7)            & $3.6 \cdot 10^5$  & $6.0 \cdot 10^5$ \\
    RIP (4 маршрутизатора)  & $1.6 \cdot 10^8$  & $4.8 \cdot 10^9$ \\
    \hline
  \end{tabular}
  \caption{Количество состояний и переходов в различных моделях}
\label{tab:models-statecount}
\end{table}

Из табл. \ref{tab:models-statecount} видно, что для реальных моделей традиционный подход
становится проблематичен: к примеру, модель RIP-протокола с 5-ю маршрутизаторами потребует
уже более 100 Гб оперативной памяти для хранения пространства состояний.

Существует ряд подходов, решающих данную проблему. Среди них можно выделить:

\begin{itemize}
\item методы оптимизации, уменьшающие количество генерируемых и хранимых состояний;
\item методы оптимизации, уменьшающие расход памяти на хранение пространства состояний;
\end{itemize}

Далее в \ref{sec:bit-hashing}--\ref{sec:state-compression} описан ряд таких методов,
используемых верификатором SPIN.

\section{Сокращение частных порядков}
\label{sec:partial-order-reduction}

Сокращение частных порядков (\Term{partial order reduction})~\cite{POD} относится к первой
группе: оно уменьшает количество генерируемых состояний. Данный метод использует тот факт,
что зачастую порядок выполнения двух переходов в различных процессах не оказывает влияния
на результат верификации.

Пример показан на рис.~\ref{fig:partial-order-reduction} слева: допустим, нас интересует
выполнение свойства $p$ в каждом из состояний системы. $\alpha$ и $\beta$~--- два перехода
различных процессов $P_{\alpha}$ и $P_{\beta}$, которые оба возможны в состоянии $s_0$
(т.е. $P_{\alpha}$ и $P_{\beta}$ не заблокированы). При этом переход $\beta$ нарушит
свойство $p$. В том случае, если выполнение свойства $p$ не зависит от перехода $\alpha$,
порядок выполнения этих двух переходов не важен, следовательно, генерацию состояния $s_2$
можно предотвратить (на рис.~\ref{fig:partial-order-reduction} справа).

\begin{figure}[ht]
  \begin{array}{p{0.4\textwidth}p{0.2\textwidth}p{0.2\textwidth}}
  \begin{tikzpicture}[->,>=stealth',auto,node distance=4cm,semithick]
    \tikzstyle{every state}=[fill=none,draw=black,text=black]
    \node[state]     (A)                    {$s_0:~~p~$};
    \node[state]     (B) [below right of=A] {$s_1:~~p~$};
    \node[state]     (C) [below left  of=A] {$s_2:~\neg p$};
    \node[state]     (D) [below right of=C] {$s_3:~\neg p$};
    
    \path (A) edge node {$\alpha$} (B)
              edge node {$\beta$}  (C)
          (B) edge node {$\beta$}  (D)
          (C) edge node {$\alpha$} (D);
  \end{tikzpicture}
  & 
  &
  \begin{tikzpicture}[->,>=stealth',auto,node distance=4cm,semithick]
    \tikzstyle{every state}=[fill=none,draw=black,text=black]
    \node[state]          (A)                    {$s_0:~p~$};
    \node[state]          (B) [below right of=A] {$s_1:~p~$};
    \node[state]          (D) [below left  of=B] {$s_3:~\neg p$};
    
    \path (A) edge node {$\alpha$} (B)
          (B) edge node {$\beta$}  (D);
  \end{tikzpicture}
  \end{array}
  \caption{Демонстрация сокращения частных порядков}
  \label{fig:partial-order-reduction}
\end{figure}

Сокращение частных порядков возможно далеко не для любых пар переходов, допустимых в
данном состоянии:

\begin{itemize}
\item переходы не должны влиять на выпонимость друг друга
\item (коммутативность) оба перехода должны приводить к одному и тому же состоянию
  вне зависимости от порядка выполнения: $Next(Next(s_0)) = \{ s_3 \}$
\end{itemize}

В случае, если два процесса обращаются к глобальным переменным и/или
используют каналы для взаимодействия, множество переходов, для которых
допустимо сокращение частных порядков, существенно уменьшается. Кроме
того, проверка на наличие циклов делает СЧП невозможным. Однако, в тех
случаях, когда это допустимо, верификатор SPIN применяет метод СЧП для
уменьшения пространства состояний.

% http://tele.informatik.uni-freiburg.de/Teaching/ss02/dres/dres.part8.pdf

\section{Битовое хэширование состояний}
\label{sec:bit-hashing}

При битовом хэширование состояний (\Term{bit-state hashing})~\cite{BitHash1} вместо
традиционной хэш-таблицы для хранения состояний используется битовая таблица. Каждое
состояние \Code{S} представлено в ней битом с номером \Code{i = hash(S)}. Нулевой бит
означает, что состояние еще не было достигнуто, единичный — было. ПРи этом вся
используемая память отводится под хэш-таблицу (сами состояния не хранятся). При размере
состояния в 20-30 байт это позволяет хранить в 160-240 больше состояний, чем при
традиционном подходе.

К сожалению, коллизии в этом случае обнаружить невозможно -- состояния будут просто
<<теряться>>, поэтому приходится просто полагаться на то, что коллизий не возникнет (для
этого надо обеспечить низкую степень заполненности таблицы) или что <<потерянные>>
состояния не повлияют на итог. Такой подход сильно снижает надежность получаемого
результата, поэтому в чистом виде битовое хэширование используется крайне редко.

Пусть под хэш отводится $m$ бит ($M = 2^m$~--- количество бит в хэш-таблице), $N$ -- число
состояний в $S$. Вероятность наличия коллизий в этом случае составляет
\begin{equation}
  \label{eq:bithash-single-coll}
  P_1 = 1 - \frac{2^m}{N},
\end{equation}
При больших $N >> M$ (а именно этот случай нас интересует) $P_1 \approx 1$, т.е. коллизии
почти наверняка возникнут.

Возможные решения включают в себя:

\begin{enumerate}
\item Использование нескольких независимых хэш-функций. Каждое состояние имеет, таким
  образом, несколько индексов (\Code{{i1 = hash1(S), i2 = hash2(S), ... in = hashn(S)}}) и
  считается найденным в хэш-таблице только в том случае, если все биты \Code{{i1, i2,
      ... in}} установлены. Вероятность возникновения коллизий, согласно~\cite{BitHash1},
  в этом случае составляет
  \begin{equation}
    \label{eq:bithash-multi-coll}
    P_h = \frac{(2 h)^h}{h+1} (P_1)^h,
  \end{equation}
  что уже при $h = 2$ дает приемлемый результат. Верификатор SPIN по умолчанию использует
  3 хэш-функции при активированном битовом хэшировании.

\item Использование традиционной хэш-таблицы, в которой вместо самих состояний хранятся их
  хэш-коды, полученные при помощи хэш-функции \Code{hash*(S)} большей разрядности
  (например, 64 бита). Функция \Code{hash*} должна быть независима от \Code{hash},
  используемой для индексации в этой таблице \cite{BitHash1}. Данный подход применим, если
  исходное состояние имеет куда больший, чем 64 бита, размер, и объем памяти достаточен,
  чтобы хранить целиком хэш-таблицу, содержащую 64-битные хэши (т.е. $2^m > 64 N$). При
  $2^m < 100 N$ эффектиность подхода в сравнении с использованием независимых хэш-функций
  резко падает.
\end{enumerate}

\section{Сжатие состояний}
\label{sec:state-compression}

% http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.308
% http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.38.308&rep=rep1&type=pdf

Альтернативным способом, позволяющим уменьшить требуемый объем памяти ценой уменьшения
скорости генерации, является сжатие хранимых состояний.

Можно предложить следующие способы сжатия состояний:

\begin{enumerate}
\item Сжатие при помощи кодов Хаффмана. Согласно исследованию из \cite{StateCompr}, в ходе
  которого было рассмотрен ряд моделей из реальных задач, в состояниях преобладают байты с
  малыми значениями, т.е. распределение значений байт в состояниях неравномерно; это
  делает коды Хаффмана хорошо применимыми. Недостатком кодов Хаффмана является
  существенное замедление работы (до 200\%).

\item <<Рекурсивная индексация>> состояний использует тот факт, что состояние $s$ включает
  в себя набор состояний отдельных процессов $s_{P_0}, s_{P_1}, ... s_{P_N}$; поскольку
  размер пространства состояний отдельно взятого процесса гораздо меньше, чем для всей
  системы, можно хранить локальные состояния процессов в отдельной хэш-таблице. При этом в
  глобальном состоянии по-прежнему хранятся значения глобальных переменных и содержимое
  каналов; все локальные состояния выносятся во вторичную хэш-таблицу, а их индексы
  хранятся в глобальном состоянии вместо них самих. Согласно \cite{StateCompr}, выгоднее
  использовать одну вторичную хэш-таблицу вместо отдельных таблиц для каждого типа
  процессов (proctype). Недостатком данного подхода является необходимость заранее (на
  этапе генерации кода или при его инициализации) выбирать, сколько бит в состоянии
  отводить под индексы в хэш-таблицу локальных состояний (если впоследствии окажется, что
  размер вторичной таблицы недостаточен для хранения всех состояний, ее увеличение будет
  невозможно, так как потребовало бы пересчета всех уже сгенерированных состояний).
\end{enumerate}

В \cite{StateCompr} предлагается еще ряд методов сжатия, выгодных для частных случаев
задач, однако в рамках данной работы они не рассматриваются.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
