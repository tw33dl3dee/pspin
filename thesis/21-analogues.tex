
\section{Существующие реализации }
\label{sec:analogues}

Существует большое количество программных средств для проверки свойств моделей, наиболее
универсальным и распространенным из которых является ПО \Code{Spin}~\cite{SpinRoot}. Он и
будет использоваться в качестве основы для дальнейшей работы. Для описания моделей в ПО
Spin используется язык описания \Code{Promela} (PROtocol Meta Language).

\subsection{Язык описания протоколов Promela}
\label{sec:promela}

Модель на языке Promela описывается в виде набора процессов (\Term{proctype}) $P_1, P_2,
... P_N$, выполняющих набор инструкций. Каждый процесс $P_i$ имеет свое состояние
$s_{p_i}$ , включащее его текущий указатель инструкции (\Term{instruction pointer}) $IP_i$
и значения локальных переменных. Для обмена данными между процессами используются
\Term{каналы}, представляющие из себя буфера фиксированного размера.

Состояния всех существующих процессов, значения глобальных переменных и содержимое каналов
образуют состояние всей системы $s$.

Каждая инструкция может иметь свое \Term{условие выполнимости}, определяющее возможность
перехода процесса к следующей инструкции. Например, инструкция посылки байта в канал
выполнима тогда, когда канал не полон.

Таким образом, если сравнивать с математической моделью из
раздела~\ref{sec:kripke-formalization}, процессы языка Promela эквивалентны автоматам
Мили, формализующим компоненты системы, при этом $IP$ процесса представляет собой номер
состояния автомата, входные последовательности -- условия выполнимости инструкций, а сами
инструкции~--- выходные последовательности. Состояние $s$ соответствует состоянию в модели
Крипке $M$, при этом набор значений глобальных и локальных переменных и содержимого
каналов соответствует набору значений переменных $V$ в $M$.

Процесс \Term{заблокирован}, если его текущая инструкция невыполнима. Если процесс не
заблокирован, он может выполнить текущую инструкцию и перейти к следующей, тем самым меняя
состояние системы (и, как его часть, свое состояние). Это называется переходом системы
(transition). За один переход только один процесс может выполнить одну инструкцию. После
того, как процесс выполняет последнюю инструкцию (если это не инструкция перехода), он
переходит в заблокированное состояние.

У инструкции может быть одна (последовательное выполнение) или несколько (ветвление)
последующих инструкций. Это соответствует одной или нескольким дугам, ведущим из
соответствующего состояния в автомате Мили. Возможна также огранизация циклов (\Code{do})
и переходов на произвольную инструкцию (\Code{goto}).

Если между состояниями $s$ и $s'$ есть переход (т.е. в $s$ есть незаблокированные процесс,
выполнение которым текущей инструкции переведет сосотяние $s$ в $s'$), будем говорить, что
$s$ и $s'$ принадлежат отношению перехода:

\begin{equation}
  \label{eq:statetrans-def}
  s \StateTrans s'
\end{equation}

Такое отношение перехода эквивалентно отношению $R$, определенному для модели Крипке $M$.

Множество незаблокированных процессов в $s$ будем обозначать как $P_{Ready}(s)$.
Множество состояний, в которые система может перейти из состояния $s$, будем обозначать

\begin{equation}
  \label{eq:next-def}
  Next(s) = \{ s': s \StateTrans s' \}
\end{equation}

Поскольку каждому незаблокированному процессу в $P_{Ready}(s)$ соответствует свой переход
в $Next(s)$, мощности этих множеств равны.

Состояние $s$ называется \Term{финальными} (тупиковым), если из него невозможен переход в
какое-либо другое ($Next(S) = \varnothing$). В финальном состоянии все процессы находятся в
заблокированном состоянии (возможно, по причине достижения последней инструкции). Такие
состояния соответствуют состояниям $s$ модели Крипке $M$, для которых $R(s, s')
\Leftrightarrow s \equiv s'$.

В начальном состоянии $s_0$ системы все каналы пусты, глобальные переменные имеют
принимают начальные значения, существует определенный набор начальных процессов, локальные
переменные которых равны своим начальным значениям и $IP_i$ указывают на начальные
инструкции.

Полным множеством состояний $S$ системы является замыкание начального
состояния системы относительно отношения $\StateTrans$:

\begin{equation}
  \label{eq:statespace-def}
  S = \{s: s_0 \StateTrans \mbox{}^* s\}
\end{equation}

Следует отметить, что это не совсем эквиваленто множеству состояний $S$ модели Крипке, которое
определено как множество \emph{всех} возможных наборов значений переменных, однако
практический смысл имеют лишь достижимые из $s_0$ состояния, поэтому в дальнейшем мы будем
понимать $S$ в смысле (\ref{eq:statespace-def}).

Ниже в качестве примера приведено описание модели обедающих философов на языке
Promela. Число философов~--- $5$, каждый из них сначала дожидается доступности левой вилки
(и берет ее), затем дожидается доступности правой.

\label{code:philo}

\begin{lstlisting}[float,language=Promela,style=simplecode,caption={Пример описания модели
    на языке Promela}]
bit  fork[5]
byte nr_eat

active [5] proctype Philosopher() {
Think:
  atomic { fork[_pid] == 0 -> fork[_pid] = 1 };
One:
  atomic { fork[(_pid + 1)%5] == 0 -> fork[(_pid + 1)%5] = 1; 
           nr_eat++ };
Eat:
  atomic { nr_eat--; fork[(_pid + 1)%5] = 0 };
  fork[_pid] = 0;
  goto Think
}  
\end{lstlisting}

Здесь массив \Code{fork} используется для хранения состояния вилок (0~--- свободна, 1~---
занята), \Code{nr_eat}~--- количества принимающих пищу в данный момент
философов. Поведение каждого философа моделируется экземпляром процесса \Code{Philosopher}
(в начальном состоянии системы существует 5 таких экземпляров). 

Каждый процесс имеет неявную переменную \Code{_pid}, принимающую значения $0, 1 \ldots 4$
в данном случае. <<Левой>> для философа с номером \Code{_pid} будем считать вилку
\Code{fork[_pid]}, а <<правой>>~--- \Code{fork[(_pid + 1)\%5] == 0}.

Конструция \Code{atomic} группирует инструкции таким образом, что в состояниях, где $IP$
одного из процессов указывает на одну из инструкций внутри атомарного блока, остальные
процессы считаются заблокированными.

Инструкция, состоящия из одного выражения (\Code{fork[_pid]}) выполнима тогда, когда
значение этого выражения ненулевое. Таким образом, если вилка слева от философа свободна,
он может взять ее (выполнить эту и следующую инструкцию), после чего, если правая вилка
занята (условие \Code{fork[(_pid + 1)\%5] == 0} не выполняется), философ
блокируется. Иначе философ берет обе вилки и переменная \Code{nr_eat}
инкрементируется. Далее философ заканчивает есть и отдает обе вилки и переменная
\Code{nr_eat} декрементируется.

\subsection{ПО для проверки свойств модели Spin}
\label{sec:spin}

ПО Spin принимает в качестве входных данных модель многопоточной системы на языке Promela
и генерирует файл с кодом на языке С. Полученный код выполняет исчерпывающий поиск по $S$
в глубину, добавляя посещенные состояния в хэш-таблицу.

Поддерживаются следующие виды проверяемых утверждений. 

Проверка значений переменных в определенных состояниях. Для этого используется встроенная
функция \Code{assert}. В случае, если проверяемое условие не выполняется (значение
выражения равно 0), Spin выдает уведомление об ошибке и сохраняет файл с трассой (стеком
обхода в глубину), по которой можно далее восстановить последовательность переходов (путь
$\pi$), приведшую к ошибочному состоянию.

Недопустимые финальные состояния: по умолчанию предполагается, что допустимыми являются
только те финальные состояния, в которых $IP$ всех процессов указывает на последнюю
инструкцию (т.е. все процессы полностью выполнились), однако можно явно указать (при
помощи специальных меток), на каких инструкциях процесс может находиться в допустимых
конечных состояниях. Данный вид проверки позволяет, например, определить, что приведенная
выше модель обедающих философов имеет недопустимое финальные состояние, в котором каждый
философ взял по одной вилке и ожидает другой (все находятся на метке \Code{Other}, все
заблокированы, поэтому состояние является финальным). Эти два вида утверждений относится к
условиям <<живости>>, описанным в разделе~\ref{sec:kripke-verification}.

Проверка достижимости инструкций: в случае, если какая-то инструкция процесса $P_i$ ни
разу не выполнялись (т.е. во всем пространстве $S$ нет ни одного состояния, в котором
$IP_i$ содержит номер этой инструкции), выдается сообщение о недостижимой инструкции.

Как уже было сказано в разделе~\ref{sec:kripke-verification}, выражаемые с помощью LTL
условия <<живости>> сводятся к наличию в каждом пути $\pi$ цикла, включающего определенные
состояния модифицированной модели $M'$. Spin поддерживает такой вид утверждений, однако,
его использование накладывает ряд ограничений на процесс генерации состояний и делает
невозможным использование многих оптимизаций~\cite{SpinRoot}.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
