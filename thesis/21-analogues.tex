\chapter{Анализ существующих средств}
\label{cha:analogues}

Существует большое количество программных средств для проверки моделей, наиболее
универсальным и распространенным из которых является верификатор \Term{SPIN}
\cite{SpinRoot}. Он и будет использоваться в качестве основы для дальнейшей работы. Для
описания моделей в верификаторе SPIN используется язык описания \Term{PROMELA} (PROtocol
  Meta Language).

\section{Язык PROMELA}
\label{sec:promela}

Модель на языке PROMELA описывается в виде набора процессов (\Term{proctype}), $P_1, P_2,
... P_N$, выполняющих набор инструкций. Каждый процесс $P_i$ имеет свое состояние
$s_{p_i}$ , включащее его текущий указатель инструкции (\Term{instruction pointer}) $IP_i$
и значения локальных переменных. Для обмена данными между процессами используются
\Term{каналы}, представляющие из себя буфера фиксированного размера.

Состояния всех существующих процессов, значения глобальных переменных и содержимое каналов
образуют состояние всей системы $S$.

Таким образом, если сравнивать с математической моделью из 

Каждая инструкция может иметь свое условие выполнимости (executability), определяющее
возможность перехода процесса к следующей инструкции. Например, инструкция посылки байта в
канал выполнима тогда, когда канал не полон.

Процесс \Term{заблокирован}, если его текущая инструкция невыполнима. Если процесс не
заблокирован, он может выполнить текущую инструкцию и перейти к следующей, тем самым меняя
состояние системы (и, как его часть, свое состояние). Это называется переходом системы
(transition). За один переход только один процесс может выполнить одну инструкцию. После
того, как процесс выполняет последнюю инструкцию (если это не инструкция перехода), он
переходит в заблокированное состояние.

Если между состояниями $s$ и $s'$ есть переход (т.е. в $s$ есть незаблокированные процесс,
выполнение которым текущей инструкции переведет сосотяние $s$ в $s'$), будем говорить, что
$s$ и $s'$ принадлежат отношению перехода:

\begin{equation}
  \label{eq:statetrans-def}
  s \StateTrans s'
\end{equation}

Множество таких незаблокированных процессов в $s$ будем обозначать как $P_{Ready}(s)$.
Множество состояний, в которые система может перейти из состояния $s$, будем обозначать

\begin{equation}
  \label{eq:next-def}
  Next(s) = \{ s': s \StateTrans s' \}
\end{equation}

Поскольку каждому незаблокированному процессу в $P_{Ready}(s)$ соответствует свой переход
в $Next(s)$, мощности этих множеств равны.

Состояние $s$ называется финальными, если из него невозможен переход в какое-либо другое
($Next(S) = \emptyset$). В финальном состоянии все процессы находятся в заблокированном
состоянии (возможно, по причине достижения последней инструкции).

В начальном состоянии $s_0$ системы все каналы пусты, глобальные переменные имеют
принимают начальные значения, существует определенный набор начальных процессов, локальные
переменные которых равны своим начальным значениям и $IP_i$ указывают на начальные
инструкции.

Полным множеством состояний $S$ системы является замыкание начального
состояния системы относительно отношения $\StateTrans$:

\begin{equation}
  \label{eq:statespace-def}
  S = \{s: s_0 \StateTrans \mbox{}^* s\}
\end{equation}

Ниже в качестве примера приведено описание модели обедающих философов на языке
PROMELA. Число философов -- $5$, каждый из них сначала дожидается доступности левой вилки
(и берет ее), затем дожидается доступности правой.

\label{code:philo}

\begin{CodeBlock}
bit  fork[5]
byte nr_eat

active [5] proctype Philosopher() \{
Think:
  atomic \{ fork[_pid] == 0 -> fork[_pid] = 1 \};
One:
  atomic \{ fork[(_pid + 1)%5] == 0 -> fork[(_pid + 1)%5] = 1; 
           nr_eat++ \};
Eat:
  atomic \{ nr_eat--; fork[(_pid + 1)%5] = 0 \};
  fork[_pid] = 0;
  goto Think
\}  
\end{CodeBlock}

Здесь массив \Code{fork} используется для хранения состояния вилок (0 -- свободна, 1 --
занята), \Code{nr_eat} -- количества принимающих пищу в данный момент философов. Поведение
каждого философа моделируется экземпляром процесса \Code{Philosopher} (в начальном
состоянии системы существует 5 таких экземпляров).

Конструция \Code{atomic} группирует инструкции таким образом, что в состояниях, где $IP$
одного из процессов указывает на одну из инструкций внутри атомарного блока, остальные
процессы считаются заблокированными.

Инструкция, состоящия из одного выражения (\Code{fork[_pid]}) выполнима тогда, когда
значения этого выражения ненулевое. Таким образом, если вилка слева от философа свободна,
он может взять ее (выполнить эту и следующую инструкцию), после чего, если правая вилка
занята (условие \Code{fork[(_pid + 1)\%5] == 0} не выполняется), философ
блокируется. Иначе философ берет обе вилки и переменная \Code{nr_eat}
инкрементируется. Далее философ заканчивает есть и отдает обе вилки и переменная
\Code{nr_eat} декрементируется.

!!! тут граф !!!

\section{Верификатор SPIN}
\label{sec:spin}

Верификатор SPIN принимает в качестве входных данных модель на языке PROMELA и генерирует
файл с кодом на языке С. Полученный код выполняет исчерпывающий поиск в глубину по
пространству состояний, добавляя новые состояния в хэш-таблицу состояний.

Для собственно верификации моделей используется следующий ряд (включаемых) проверок:

\begin{enumerate}
\item проверка конкретных условий в определенных состояниях. Для этого используется
  встроенная функция \Code{assert}. В случае, если проверяемое условие не выполняется
  (значение выражения равно 0), SPIN выдает уведомление об ошибке и сохраняет файл с
  трассой (стеком обхода в глубину), по которой можно далее восстановить
  последовательность переходов, приведшую к ошибочному состоянию;

\item проверка достижимости инструкций. В случае, если какая-то инструкция ни разу не
  выполнялись каким-либо процессом (т.е. во всем пространстве $S$ нет ни одного состояния,
  в котором $IP$ данного процесса содержит номер этой инструкции), выдается сообщение о
  недостижимых инструкциях.

\item проверка на недопустимые финальные состояния. По умолчанию предполагается, что
  допустимыми являются только те финальные состояния, в которых $IP$ всех процессов
  указывает на последнюю инструкцию (т.е. все процессы полностью выполнились), однако
  можно явно указать (при помощи специальных меток), на каких инструкциях процесс может
  находиться в допустимых конечных состояниях. Данный вид проверки, например, определить,
  что приведенная выше модель обедающих философов имеет недопустимое финальные состояние,
  в котором каждый философ взял по одной вилке и ожидает другой (все находятся на метке
  \Code{Other}, все заблокированы, поэтому состояние является финальным).
\end{enumerate}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "thesis"
%%% End: 
