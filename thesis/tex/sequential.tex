\chapter{Последовательная генерация состояний}
\label{sec:seq-statespace}

\section{Алгоритм построения}
\label{sec:seq-algo}

Последовательный алгоритм построения пространства состояний,
используемый верификатором SPIN, можно представить следующим
псевдокодом:

\begin{CodeBlock}
Visited = []
def StateSpaceDFS(state):
    if not state in Visited:
        Visited += state
        for each state' in Next(state):
            StateSpaceDFS(state')
StateSpaceDFS(start)
\end{CodeBlock}

Последовательное построение пространства состояний $S$ с ростом
размера модели быстро становится невозможным из-за нехватки памяти для
хранения множества достигнутых состояний (\Code{Visited}). В
табл. \ref{fig:models-statecount} приведены данные для двух моделей:
модели 5 обедающих философов и более приближенной к реальным задачам
модели RIP-протокола на 4 сетевых маршрутизаторах.

\begin{figure}
  \centering
  \begin{tabular}{r|l}
    !!! \\  
  \end{tabular}
  \caption{Количество состояний и переходов в различных моделях}
\label{fig:models-statecount}
\end{figure}

Из табл. \ref{fig:models-statecount} видно, что для реальных моделей
традиционный подход становится проблематичен: к примеру, модель
RIP-протокола с 5-ю маршрутизаторами потребует уже более 100 Гб
оперативной памяти для хранения пространства состояний. 

Можно предложить два решения проблемы: использование оптимизаций,
сокращающих расход памяти (посредством уменьшения пространства
хранимых состояний или количества байт на состояние), и параллельная
генерация состояний с распределением хранимых состояний между
различными узлами вычислительной сети.

Программный код, генерируемый верификатором SPIN, использует ряд
оптимизаций, описанных далее в \ref{sec:bit-hashing}-~\ref{sec:state-compression}.

\section{Битовое хэширование состояний}
\label{sec:bit-hashing}

Одной из оптимизаций, позволяющей сократить расходуемый объем памяти,
является так называемое битовое хэширование состояний (\Term{bit-state
hashing}). Суть его заключается в том, что вместо традиционной
хэш-таблицы, с открытой индексацией или со списками, для хранения
состояний используется битовая таблица. Каждое состояние \Code{S}
представлено в ней битом с номером \Code{i = hash(S)}. Нулевой бит означает,
что состояние еще не было достигнуто, единичный — было. В чистом виде
битовое хэширование не применяется из-за высокой вероятности коллизий
[1]. Возможные решения включают в себя:

\begin{enumerate}
\item Использование нескольких независимых хэш-функций. Каждое
  состояние имеет, таким образом, несколько индексов (\Code{{i1 = hash1(S),
    i2 = hash2(S), ... in = hashn(S)}}) и считается найденным в
  хэш-таблице только в том случае, если все биты \Code{{i1, i2, ... in}}
  установлены.

\item Использование традиционной хэш-таблицы, в которой вместо самих
  состояний хранятся их хэш-коды, полученные при помощи хэш-функции
  \Code{hash*(S)} большей разрядности (например, 64 бита). Функция \Code{hash*}
  должна быть независима от \Code{hash}, используемой для индексации в этой
  таблице [1].
\end{enumerate}

!!! Тут можно немного вхерачить из литры

\section{Сжатие состояний}
\label{sec:state-compression}

% http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.308
% http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.38.308&rep=rep1&type=pdf

\section{Сокращение частных порядков}
\label{sec:partial-order-reduction}

% http://tele.informatik.uni-freiburg.de/Teaching/ss02/dres/dres.part8.pdf

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
