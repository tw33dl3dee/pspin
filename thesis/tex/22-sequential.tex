\chapter{Последовательная генерация состояний}
\label{sec:seq-statespace}

\section{Алгоритм построения}
\label{sec:seq-algo}

Последовательный алгоритм построения пространства состояний,
используемый верификатором SPIN, можно представить следующим
псевдокодом:

\begin{CodeBlock}
Visited = []
def StateSpaceDFS(state):
    if not state in Visited:
        Visited += state
        for each state' in Next(state):
            StateSpaceDFS(state')
StateSpaceDFS(start)
\end{CodeBlock}

Последовательное построение пространства состояний $S$ с ростом размера модели
быстро становится невозможным из-за нехватки памяти для хранения множества
достигнутых состояний (\Code{Visited}). В табл. \ref{tab:models-statecount}
приведены данные для двух моделей: модели задачи об обедающих философов из
\ref{sec:promela} и более приближенной к реальным задачам модели RIP-протокола
на 4 сетевых маршрутизаторах.

\begin{table}
  \centering
  \begin{tabular}{|r|l|l|}
    \hline
    Модель                  & Состояний         & Переходов       \\
    \hline
    Философы (5)            & $2.8 \cdot 10^4$  & $4.2 \cdot 10^4$ \\
    Философы (7)            & $3.6 \cdot 10^5$  & $6.0 \cdot 10^5$ \\
    RIP (4 маршрутизатора)  & $1.6 \cdot 10^8$  & $4.8 \cdot 10^9$ \\
    \hline
  \end{tabular}
  \caption{Количество состояний и переходов в различных моделях}
\label{tab:models-statecount}
\end{table}

Из табл. \ref{tab:models-statecount} видно, что для реальных моделей
традиционный подход становится проблематичен: к примеру, модель
RIP-протокола с 5-ю маршрутизаторами потребует уже более 100 Гб
оперативной памяти для хранения пространства состояний. 

Можно предложить два решения проблемы: использование оптимизаций,
сокращающих расход памяти (посредством уменьшения пространства
хранимых состояний или количества байт на состояние), и параллельная
генерация состояний с распределением хранимых состояний между
различными узлами вычислительной сети.

Программный код, генерируемый верификатором SPIN, использует ряд
оптимизаций, описанных далее в \ref{sec:bit-hashing}-~\ref{sec:state-compression}.

\section{Битовое хэширование состояний}
\label{sec:bit-hashing}

Одной из оптимизаций, позволяющей сократить расходуемый объем памяти,
является так называемое битовое хэширование состояний (\Term{bit-state
  hashing}). Суть его заключается в том, что вместо традиционной
хэш-таблицы, с открытой индексацией или со списками, для хранения
состояний используется битовая таблица. Каждое состояние \Code{S}
представлено в ней битом с номером \Code{i = hash(S)}. Нулевой бит
означает, что состояние еще не было достигнуто, единичный — было. В
чистом виде битовое хэширование не применяется из-за высокой
вероятности коллизий \cite{BitHash1}. Возможные решения включают в
себя:

\begin{enumerate}
\item Использование нескольких независимых хэш-функций. Каждое
  состояние имеет, таким образом, несколько индексов (\Code{{i1 = hash1(S),
    i2 = hash2(S), ... in = hashn(S)}}) и считается найденным в
  хэш-таблице только в том случае, если все биты \Code{{i1, i2, ... in}}
  установлены.

\item Использование традиционной хэш-таблицы, в которой вместо самих
  состояний хранятся их хэш-коды, полученные при помощи хэш-функции
  \Code{hash*(S)} большей разрядности (например, 64 бита). Функция \Code{hash*}
  должна быть независима от \Code{hash}, используемой для индексации в этой
  таблице \cite{BitHash1}.
\end{enumerate}

!!! Тут можно немного добавить из лит-ры

\section{Сжатие состояний}
\label{sec:state-compression}

% http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.38.308
% http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.38.308&rep=rep1&type=pdf

Альтернативным способом, позволяющим уменьшить размер требуемой для
хранения всех состояний памяти ценой уменьшения скорости генерации
является сжатие хранимых состояний. 

Можно предложить следующие способы сжатия состояний:

\begin{enumerate}
\item Сжатие при помощи кодов Хаффмана. Согласно исследованию из
  \cite{StateCompr}, в ходе которого было рассмотрен ряд моделей из
  реальных задач, в состояниях преобладают байты с малыми значениями,
  т.е. распределение значений байт в состояниях неравномерно; это
  делает коды Хаффмана хорошо применимыми. Недостатком кодов Хаффмана
  является существенное замедление работы (до 200\%).

\item <<Рекурсивная индексация>> состояний использует тот факт, что
  состояние $s$ включает в себя набор состояний отдельных процессов
  $s_{P_0}, s_{P_1}, ... s_{P_N}$; поскольку размер пространства состояний
  отдельно взятого процесса гораздо меньше, чем для всей системы,
  можно хранить локальные состояния процессов в отдельной
  хэш-таблице. При этом в глобальном состоянии по-прежнему хранятся
  значения глобальных переменных и содержимое каналов; все локальные
  состояния выносятся во вторичную хэш-таблицу, а их индексы хранятся
  в глобальном состоянии вместо них самих. Согласно \cite{StateCompr},
  выгоднее использовать одну вторичную хэш-таблицу вместо отдельных
  таблиц для каждого типа процессов (proctype). Недостатком данного
  подхода является необходимость заранее (на этапе генерации кода или
  при его инициализации) выбирать, сколько бит в состоянии отводить
  под индексы в хэш-таблицу локальных состояний (если впоследствии
  окажется, что размер вторичной таблицы недостаточен для хранения
  всех состояний, ее увеличение будет невозможно, так как потребовало
  бы пересчета всех уже сгенерированных состояний).
\end{enumerate}

В \cite{StateCompr} предлагается еще ряд методов сжатия, выгодных для
частных случаев задач, однако в рамках данной работы они не
рассматриваются. 

\section{Сокращение частных порядков}
\label{sec:partial-order-reduction}

Сокращение частных порядков (\Term{partial order reduction}) \cite{POD}, в
отличие от предыдущих методов, уменьшает размер самого пространства
состояний. Данный метод использует тот факт, что зачастую порядок
выполнения двух переходов в различных процессах не оказывает влияния
на результат верификации. 

Пример показан на рис. \ref{fig:partial-order-reduction} слева:
допустим, нас интересует выполнение свойства $p$ в каждом из состояний
системы. $\alpha$ и $\beta$ -- два перехода различных процессов
$P_{\alpha}$ и $P_{\beta}$, которые оба возможны в состоянии $s_0$
(т.е. $P_{\alpha}$ и $P_{\beta}$ не заблокированы). При этом переход
$\beta$ нарушит свойство $p$. В том случае, если выполнение свойства
$p$ не зависит от перехода $\alpha$, порядок выполнения этих двух
переходов не важен, следовательно, генерацию состояния $s_2$ можно
предотвратить (на рис. \ref{fig:partial-order-reduction} справа).

\begin{figure}[ht]
  \begin{array}{p{0.4\textwidth}p{0.2\textwidth}p{0.2\textwidth}}
  \begin{tikzpicture}[->,>=stealth',auto,node distance=4cm,semithick]
    \tikzstyle{every state}=[fill=none,draw=black,text=black]
    \node[state]     (A)                    {$s_0:~~p~$};
    \node[state]     (B) [below right of=A] {$s_1:~~p~$};
    \node[state]     (C) [below left  of=A] {$s_2:~\neg p$};
    \node[state]     (D) [below right of=C] {$s_3:~\neg p$};
    
    \path (A) edge node {$\alpha$} (B)
              edge node {$\beta$}  (C)
          (B) edge node {$\beta$}  (D)
          (C) edge node {$\alpha$} (D);
  \end{tikzpicture}
  & 
  &
  \begin{tikzpicture}[->,>=stealth',auto,node distance=4cm,semithick]
    \tikzstyle{every state}=[fill=none,draw=black,text=black]
    \node[state]          (A)                    {$s_0:~p~$};
    \node[state]          (B) [below right of=A] {$s_1:~p~$};
    \node[state]          (D) [below left  of=B] {$s_3:~\neg p$};
    
    \path (A) edge node {$\alpha$} (B)
          (B) edge node {$\beta$}  (D);
  \end{tikzpicture}
  \end{array}
  \caption{Демонстрация сокращения частных порядков}
  \label{fig:partial-order-reduction}
\end{figure}

Сокращение частных порядков возможно далеко не для любых пар
переходов, допустимых в данном состоянии:

\begin{itemize}
\item переходы не должны влиять на выпонимость друг друга
\item (коммутативность) оба перехода должны приводить к одному и тому же состоянию
  вне зависимости от порядка выполнения: $Next(Next(s_0)) = \{ s_3 \}$
\end{itemize}

В случае, если два процесса обращаются к глобальным переменным и/или
используют каналы для взаимодействия, множество переходов, для которых
допустимо сокращение частных порядков, существенно уменьшается. Кроме
того, проверка на наличие циклов делает СЧП невозможным. Однако, в тех
случаях, когда это допустимо, верификатор SPIN применяет метод СЧП для
уменьшения пространства состояний.

% http://tele.informatik.uni-freiburg.de/Teaching/ss02/dres/dres.part8.pdf

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
