\chapter{Параллельная генерация состояний}
\label{sec:par-statespace}

\section{Алгоритм}
\label{sec:par-algo}

Возможны два варианта параллельной генерации состояний:

\begin{enumerate}
\item Распределенное хранилище состояний. Состояния генерирует только
  один узел, а для хранения используются все узлы. Каждое состояние
  имеет свой однозначно вычислимый номер узла. Преимуществом данного
  подхода является возможность по-прежнему использовать поиск в
  глубину, необходимый для поиска циклов. Недостаток заключается в
  том, что каждое новое состояние требует удаленного вызова (обращения
  к другому узлу) для проверки, было ли он уже достигнуто.

\item Распределенная генерация состояний. Каждый узел является
  одновременно хранилищем и генератором. Этот вариант предпочтителен,
  поскольку используется вычислительная мощность всех узлов и
  сокращается число удаленных вызовов за счет тех случаев, когда новое
  состояние принадлежит тому же самому узлу. Хотя каждый узел может
  выполнять с локальной точки зрения поиск в глубину, глобальный
  порядок достижения состояний нарушается, и поиск циклов становится
  затруднителен. В работах \cite{DLTL1}, \cite{DLTL2} было предложено
  несколько различных алгоритмов, совмещающих поиск в ширину с
  последующим нахождением циклов за счет определенной потери
  производительности. Зачастую верификация модели требует лишь
  проверки корректности конечных состояний и выполнения инвариантов, а
  в этом случае поиск циклов не требуется, что позволяет использовать
  в данном варианте обычный поиск в ширину.
\end{enumerate}

Параллельная версия алгоритма для второго случая выглядит следующим
образом:

\begin{CodeBlock}
Visited = []
Queue = []
if NodeId = 0:
    Queue += start_state
def ParStateSpaceBFS():
    while not empty(Queue):
        state <- Queue
        node = StateNode(state)
        if NodeId = node:
            if not state in Visited:
                Visited += state
                for each state' in Next(state):
                    Queue <- state'
        else:
            node.Queue <- state
ParStateSpaceBFS()
\end{CodeBlock}

\section{Распределение состояний между узлами}
\label{sec:state-partition}

В приведенном коде для определения номера узла, хранящего сообщения,
используется функция \Code{StateNode}. Эта функция должна обладать следующими
характеристиками:

\begin{itemize}
\item она должна зависеть только от самого состояния, поскольку одно и
  то же состояние может генерироваться различными узлами в результате
  различных переходов;

\item она должна по возможности распределять состояния между узлами
  равномерно;

\item она должна обладать определенной локальностью — по возможности
  новые состояния должны принадлежать тому же узлу, что и исходное,
  для уменьшения числа удаленных вызовов.
\end{itemize}

Наиболее простым подходом является в качестве \Code{StateNode} использовать
хэш-функцию от всего состояния. Это обеспечит первые 2 условия: если
выбрана подходящая хэш-функция, распределение будет достаточно
равномерным. Однако, третье условие при этом не соблюдается, поскольку
все новые состояния имеют равные шансы принадлежать любому узлу
независимо того, на каком узле они были сгенерированы.

Пусть число узлов — $N$, состояний — $S$, переходов между ними —
$T$. В случае равномерного распределения состояний между узлами
вероятность того, что следующее состояние будет принадлежать текущему
узлу равняется $\frac{1}{N}$. Следовательно, вероятность того, что
потребуется удаленный вызов, равна $1 - \frac{1}{N}$, а среднее число
удаленных вызовов в течение всей генерации составит
\begin{equation}
  \label{eq:nmsg-full-hash}
  M_{full} = T \cdot (1 - \frac{1}{N}) ,
\end{equation}
что при больших значениях $N$ стремится с $T$. Как
показывают эксперименты в \cite{LT99}, столь частые пересылки
состояний негативно отражаются на производительности, поэтому
необходимо найти более удачное распределение состояний, которое бы
удовлетворяло условию локальности.

В данной работе предлагается для распределения состояний по узлам
хэшировать не все состояние целиком, а лишь локальное состояние одного
процесса. В этом случае удаленный вызов будет происходить лишь при
переходах, изменяющих локальное состояние этого процесса.

Пусть $P$ — число процессов в модели, $k$ — среднее число процессов,
затрагиваемых переходом (состояние которых меняется при переходе). $k
> 1$, так как возможна (атомарная) передача сообщений между
процессами, при которой сообщение меняют одновременно 2 процесса. $k <
2$, так как взаимодействие трех или более процессов в языке Promela
нереализуемо.

Если предположить, что каждый процесс участвует примерно в равной доле
переходов, то для произвольного наперед заданного процесса вероятность
участия в данном переходе составит $\frac{k}{P}$. Если
\Code{StateNode} отображает множество локальных состояний процесса на
множество узлов равномерным образом, то, по аналогии с предыдущими
рассуждениями, вероятность удаленного вызова при изменении состояния
процесса составит $1 - \frac{1}{N}$. Количество удаленных вызовов во
всей модели, таким образом, равняется
\begin{equation}
  \label{eq:nmsg-firstproc-hash}
  M_{part} = \frac{k}{P} \cdot (1 - \frac{1}{N})
\end{equation}
и с ростом $N$ стремится к $T \cdot \frac{k}{P}$. При
количестве процессов $P = 6-8$ и $k = 1.5$, т.е. когда половина переходов
приходится на взаимодействия процессов, получаем в $P/k = 4-5$ раз
меньше удаленных вызовов, чем при хэшировании состояния целиком.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
