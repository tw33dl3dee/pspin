\chapter{Рассмотрение существующих средств}
\label{cha:analogues}

Основным программным средством для подобной проверки конечных моделей
является \Term{SPIN} \cite{SpinRoot}. Для описания модели в нем используется язык описания
Promela (\Term{PROtocol Meta Language}).

\section{Язык PROMELA}
\label{sec:promela}

Модель на языке PROMELA описывается в виде набора процессов
(\Term{proctype}), $P_1, P_2, ... P_N$, выполняющих инструкции. Каждый
процесс $P_i$ имеет свое состояние $s_{p_i}$ , включащее его текущий указатель
инструкции (\Term{instruction pointer}) $IP_i$ и значения
локальных переменных. Для обмена данными между процессами используются
\Term{каналы}, представляющие из себя буфера фиксированного размера.

Состояния всех существующих процессов, значения глобальных переменных
и содержимое каналов образуют состояние всей системы $S$.

Каждая инструкция может иметь свое условие выполнимости
(executability), определяющее возможность перехода процесса к
следующей инструкции. Например, инструкция посылки байта в канал
выполнима тогда, когда канал не полон.

Процесс \Term{заблокирован}, если его текущая инструкция
невыполнима. Если процесс не заблокирован, он может выполнить текущую
инструкцию и перейти к следующей, тем самым меняя состояние системы
(и, как его часть, свое состояние). Это называется переходом системы
(transition). За один переход только один процесс может выполнить одну
инструкцию.

Если между состояниями $s$ и $s'$ есть переход (т.е. в $s$ есть
незаблокированные процесс, выполнение которым текущей инструкции
переведет сосотяние $s$ в $s'$), будем говорить, что $s$ и $s'$
принадлежат отношению перехода:

\begin{equation}
  \label{eq:statetrans-def}
  s \StateTrans s'
\end{equation}

В начальном состоянии $s_0$ системы все каналы пусты, глобальные переменные
имеют принимают начальные значения, существует определенный набор
начальных процессов, локальные переменные которых равны своим
начальным значениям и $IP_i$ указывают на начальные инструкции. 

Полным множеством состояний $S$ системы является замыкание начального
состояния системы относительно отношения $\StateTrans$:

\begin{equation}
  \label{eq:statespace-def}
  S = \{s: s_0 \StateTrans \mbox{}^* s\}
\end{equation}

Ниже в качестве примера приведено описание модели обедающих философов
на языке PROMELA. Число философов -- $5$, каждый из них сначала
дожидается доступности левой вилки (и берет ее), затем дожидается
доступности правой.

\begin{CodeBlock}
bit  fork[5]
byte nr_eat

active [5] proctype Philosopher() \{
Think:
  atomic \{ fork[_pid] == 0 -> fork[_pid] = 1 \};
One:
  atomic \{ fork[(_pid + 1)%5] == 0 -> fork[(_pid + 1)%5] = 1; 
           nr_eat++ \};
Eat:
  atomic \{ nr_eat--; fork[(_pid + 1)%5] = 0 \};
  fork[_pid] = 0;
  goto Think
\}  
\end{CodeBlock}

Здесь массив \Code{fork} используется для хранения состояния вилок (0
-- свободна, 1 -- занята), \Code{nr_eat} -- количества принимающих
пищу в данный момент философов. Поведение каждого философа
моделируется экземпляром процесса \Code{Philosopher} (в начальном
состоянии системы существует 5 таких экземпляров).

Конструция \Code{atomic} группирует инструкции таким образом, что
в состояниях, где $IP$ одного из процессов указывает на одну из
инструкций внутри атомарного блока, остальные процессы считаются
заблокированными.

Инструкция, состоящия из одного выражения (\Code{fork[_pid]})
выполнима тогда, когда значения этого выражения ненулевое. Таким
образом, если вилка слева от философа свободна, он может взять ее
(выполнить эту и следующую инструкцию), после чего, если правая вилка
занята (условие \Code{fork[(_pid + 1)\%5] == 0} не выполняется),
философ блокируется. Иначе философ берет обе вилки и переменная
\Code{nr_eat} инкрементируется. Далее философ заканчивает есть и
отдает обе вилки и переменная \Code{nr_eat} декрементируется.

\section{Верификатор SPIN}
\label{sec:spin}

Верификатор SPIN принимает в качестве входных данных модель на языке
PROMELA и генерирует файл на языке С с кодом для генерации полного
пространства состояний модели. 

При верификации модели SPIN выполняет исчерпывающий поиск в глубину по
пространству состояний и, при достижении недопустимого состояния,
сохраняет сценарий, приведший к приходу в это состояние.

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "main"
%%% End: 
